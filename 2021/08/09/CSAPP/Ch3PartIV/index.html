<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Ch3PartIV | rubbishbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="MathJax.Hub.Config({ tex2jax: {inlineMath: [[&#39;$&#39;, &#39;$&#39;]]}, messageStyle: &quot;none&quot; });   3.10 Combining Control and Data in Machine-Level ProgramsIn this section, we look at ways in which data and contro">
<meta property="og:type" content="article">
<meta property="og:title" content="Ch3PartIV">
<meta property="og:url" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/index.html">
<meta property="og:site_name" content="rubbishbin">
<meta property="og:description" content="MathJax.Hub.Config({ tex2jax: {inlineMath: [[&#39;$&#39;, &#39;$&#39;]]}, messageStyle: &quot;none&quot; });   3.10 Combining Control and Data in Machine-Level ProgramsIn this section, we look at ways in which data and contro">
<meta property="og:locale">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/gdbcmds.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/stackstat.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/canary.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/rbp.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/ymm.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/vmov.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/convert.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/floatarith.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/bitwise.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/ucmp.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/conditions.png">
<meta property="article:published_time" content="2021-08-09T08:26:54.000Z">
<meta property="article:modified_time" content="2021-08-17T12:44:07.613Z">
<meta property="article:author" content="rubbish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/gdbcmds.png">
  
    <link rel="alternate" href="/atom.xml" title="rubbishbin" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rubbishbin</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://rubbish-and-world.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-CSAPP/Ch3PartIV" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/09/CSAPP/Ch3PartIV/" class="article-date">
  <time class="dt-published" datetime="2021-08-09T08:26:54.000Z" itemprop="datePublished">2021-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/csapp/">csapp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Ch3PartIV
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>


<h2 id="3-10-Combining-Control-and-Data-in-Machine-Level-Programs"><a href="#3-10-Combining-Control-and-Data-in-Machine-Level-Programs" class="headerlink" title="3.10 Combining Control and Data in Machine-Level Programs"></a>3.10 Combining Control and Data in Machine-Level Programs</h2><p><em>In this section, we look at ways in which data and control interact with each other.</em></p>
<a id="more"></a>

<h3 id="3-10-1-Understanding-Pointers"><a href="#3-10-1-Understanding-Pointers" class="headerlink" title="3.10.1 Understanding Pointers"></a>3.10.1 Understanding Pointers</h3><p><em>Pointers are a central feature of the C programming language</em></p>
<ul>
<li><p>Every pointer has an associated type.</p>
<ul>
<li><p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data ;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;data;</span><br><span class="line"><span class="keyword">int</span>** pp = &amp;p;</span><br></pre></td></tr></table></figure></li>
<li><p>The special <code>void *</code> type represents a generic pointer. It can be converted to other type.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Every pointer has a value.This value is an <strong>address</strong> of some object of the designated type. </p>
<ul>
<li> The special <code>NULL (0)</code> value indicates that the pointer does not point anywhere.</li>
</ul>
</li>
<li><p>Pointers are created with the <code>&amp;</code> operator. In machine code <code>lea</code> is often used</p>
</li>
<li><p>Pointers are dereferenced with the <code>*</code> operator.  Dereferencing is implemented by a <em>memory reference</em>, either storing to or retrieving from the specified address.</p>
</li>
<li><p>Arrays and pointers are closely related.</p>
<ul>
<li>The name of an array can be referenced (<strong>but not updated</strong>) as if it were a pointer variable</li>
</ul>
</li>
<li><p>Casting from one type of pointer to another <strong>changes its type but not its value</strong>.</p>
<ul>
<li><p>One effect of casting is to <strong>change any scaling of pointer arithmetic</strong></p>
</li>
<li><p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span> [<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> * p2c = <span class="built_in">string</span> ;</span><br><span class="line"><span class="keyword">int</span> * p2i = (<span class="keyword">int</span>*)p2c;</span><br><span class="line"><span class="built_in">string</span>[<span class="number">12</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p2c : %p , p2i : %p\n&quot;</span> , p2c ,p2i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p:%c\n&quot;</span> , (p2c+<span class="number">12</span>) , *(p2c+<span class="number">12</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p:%c\n&quot;</span> , (p2i + <span class="number">3</span>) , *(p2i + <span class="number">3</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Pointers can also point to functions</p>
<ul>
<li><p>This provides a powerful capability for storing and passing references to code, which can be invoked in some other part of the program.</p>
</li>
<li><p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> *p)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span> *);</span><br><span class="line">fp = fun;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = fp(<span class="number">3</span>, &amp;y);</span><br></pre></td></tr></table></figure>
<p>The value of a function pointer is the address of <strong>the first instruction in the machine-code representation of the function.</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-10-2-Life-in-the-Real-World-Using-the-gdb-Debugger"><a href="#3-10-2-Life-in-the-Real-World-Using-the-gdb-Debugger" class="headerlink" title="3.10.2 Life in the Real World: Using the gdb Debugger"></a>3.10.2 Life in the Real World: Using the <code>gdb</code> Debugger</h3><p><em>The GNU debugger gdb provides a number of useful features to support the run-time evaluation and analysis of machine-level programs</em></p>
<ul>
<li>It is very helpful to first run objdump to get a disassembled version of the program. </li>
<li>The general scheme is to set breakpoints near points of interest in the program.</li>
<li>gdb has an obscure command syntax, but the online help information (invoked within <code>gdb</code> with the <code>help</code> command) overcomes this shortcoming.</li>
<li>Rather than using the command-line interface to gdb, many programmers prefer using <code>ddd</code>, an extension to <code>gdb</code> that provides a graphical user interface.</li>
</ul>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/gdbcmds.png" alt="gdb commands"></p>
<p><a target="_blank" rel="noopener" href="http://beej.us/guide/bggdb/">tutorial from csapp student site</a></p>
<p><a target="_blank" rel="noopener" href="http://www.gnu.org/software/gdb/documentation/">gdb manual</a></p>
<p><code>man gdb</code></p>
<h3 id="3-10-3-Out-of-Bounds-Memory-References-and-Buffer-Overflow"><a href="#3-10-3-Out-of-Bounds-Memory-References-and-Buffer-Overflow" class="headerlink" title="3.10.3 Out-of-Bounds Memory References and Buffer Overflow"></a>3.10.3 Out-of-Bounds Memory References and Buffer Overflow</h3><p><em>We have seen that <strong>C does not perform any bounds checking for array references</strong>, and that <strong>local variables are stored on the stack along with state information such as saved register values and return addresses</strong>. This combination can lead to serious program errors, where <strong>the state stored on the stack gets corrupted by a write to an out-of-bounds array element</strong>. When the program then tries to reload the register or execute a ret instruction with this corrupted state, things can go seriously wrong.</em></p>
<p>A particularly common source of state corruption is known as <em>buffer overflow</em></p>
<p>For example, <code>gets</code> in the standard library</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Implementation of library function gets() */</span></span><br><span class="line"><span class="comment">/* gets() has been removed from stdio.h since C11 !!! */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">char</span> *dest = s;</span><br><span class="line"><span class="keyword">while</span> ((c = getchar()) != ’\n’ &amp;&amp; c != EOF)</span><br><span class="line">*dest++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line"><span class="comment">/* No characters read */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">*dest++ = ’\<span class="number">0</span>’; <span class="comment">/* Terminate string */</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">gets(buf);</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Og -S -fno-stact-protector -mpreferred-stack-boundary=3 test.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">	pushq	%rbx		# save previous sp</span><br><span class="line">	subq	$8, %rsp	# allocat 8 bytes for array buf	</span><br><span class="line">	movq	%rsp, %rbx	# save current sp</span><br><span class="line">	movq	%rbx, %rdi	# pass buf to gets function</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	gets@PLT</span><br><span class="line">	movq	%rbx, %rdi	# pass buf to puts function</span><br><span class="line">	call	puts@PLT</span><br><span class="line">	addq	$8, %rsp	# deallocate the space</span><br><span class="line">	popq	%rbx		# restore previous sp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/stackstat.png" alt="stack status"></p>
<p>(Return address is <code>%rsp+8</code> in my case)</p>
<p>Since C do not check array referrence, we can input string longer than 7 to corrupt the return address</p>
<p>A better version involves using the function <code>fgets</code>, which includes as an argument a count on the maximum number of bytes to read.</p>
<p><strong>a number of commonly used library functions, including <code>strcpy</code>, <code>strcat</code>, and <code>sprintf</code>, have the property that they can generate a byte sequence without being given any indication of the size of the destination buffer. Such conditions can lead to vulnerabilities to buffer overflow !!!</strong></p>
<h4 id="Practice-Problem-3-46"><a href="#Practice-Problem-3-46" class="headerlink" title="Practice Problem 3.46"></a>Practice Problem 3.46</h4><blockquote>
<p>Following codes shows a (low-quality) implementation of a function that reads a line from standard input, copies the string to newly allocated storage, and returns a pointer to the result.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is very low-quality code.</span></span><br><span class="line"><span class="comment">It is intended to illustrate bad programming practices.</span></span><br><span class="line"><span class="comment">See Practice Problem 3.46. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">char</span> *dest = s;</span><br><span class="line"><span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">*dest++ = c;</span><br><span class="line"><span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line"><span class="comment">/* No characters read */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">*dest++ = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* Terminate string */</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> *result;</span><br><span class="line">gets(buf);</span><br><span class="line">result = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(buf));</span><br><span class="line"><span class="built_in">strcpy</span>(result, buf);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">get_line:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	leaq	12(%rsp), %rbx</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	gets</span><br><span class="line">	movq	$-1, %rcx</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	repnz scasb</span><br><span class="line">	movq	%rcx, %rdx</span><br><span class="line">	notq	%rdx</span><br><span class="line">	leaq	-1(%rdx), %rdi</span><br><span class="line">	call	malloc@PLT</span><br><span class="line">	movq	%rbx, %rsi</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	strcpy@PLT</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>Consider the following scenario. Procedure <code>get_line</code> is called with the return address equal to 0x400776 and register <code>%rbx</code> equal to 0x0123456789ABCDEF. You type in the string “0123456789012345678901234”</p>
<p>The program terminates with a segmentation fault. You run <code>gdb</code> and determine that the error occurs during the execution of the <code>ret</code> instruction of <code>get_line</code></p>
<p>A. Fill in the diagram that follows, indicating as much as you can about the stack just after executing the instruction at line 3 in the disassembly. Label the quantities stored on the stack (e.g., “Return address”) on the right, and their hexadecimal values (if known) within the box. Each box represents 8 bytes. Indicate the position of <code>%rsp</code>. Recall that the ASCII codes for characters 0–9 are 0x30–0x39.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|00 00 00 00 00 40 07 76| Return address</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br><span class="line">|                       |</span><br></pre></td></tr></table></figure>

<p>B. Modify your diagram to show the effect of the call to <code>gets</code> .</p>
<p>C. To what address does the program attempt to return?</p>
<p>D. What register(s) have corrupted value(s) when <code>get_line</code> returns?</p>
<p>E. Besides the potential for buffer overflow, what two other things are wrong with the code for <code>get_line</code>?</p>
</blockquote>
<h4 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution:"></a>My solution:</h4><p>play it with <code>gdb</code>, there’s lots of fun.</p>
<p><span style="color:red">send raw bytes to program or gdb</span></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb&gt; r &lt; &lt;(python -c <span class="string">&quot;print &#x27;0000000000000000000000000000&#125;HUUUU\x00\x00\x6bHUUUU&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># input as file</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb&gt; r &lt;&lt;&lt; $(python -c <span class="string">&quot;print &#x27;0000000000000000000000000000&#125;HUUUU\x00\x00\x1bHUUUU&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># input as variable</span></span><br><span class="line"><span class="comment"># This one doesn&#x27;t work with bash version newer than 4.4</span></span><br><span class="line"><span class="comment"># /bin/bash: warning: command substitution: ignored null byte in input</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&#x27;0000000000000000000000000000&#125;HUUUU\x00\x00\x1bHUUUU&#x27;</span> | ./prog</span><br></pre></td></tr></table></figure>
<p>Examine stack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb&gt;x/64bx <span class="variable">$rsp</span></span><br></pre></td></tr></table></figure>
<p>Start with gui mode</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -tui prog</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it">Why it won’t work outside of gdb ? </a></p>
<p><a target="_blank" rel="noopener" href="https://cs4401.walls.ninja/notes/quick/outside_of_gdb.html">more info</a></p>
<blockquote>
<p>gdb messes with your environment variables, and could disable ASLR. Most likely, starting gdb and running ‘unset env LINES’ and ‘unset env COLUMNS’ before throwing your shellcode will make the output line up with execution outside gdb. :)</p>
</blockquote>
<p>Also, don’t forget to turn off the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> !!!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># disable</span></span><br><span class="line">$ <span class="built_in">echo</span> 0 | sudo tee /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="comment"># enable</span></span><br><span class="line">$ <span class="built_in">echo</span> 2 | sudo tee /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31478270/spawned-shell-terminates-quickly-after-buffer-overflow/31478720">How to keep the shell</a></p>
<p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/643703/bin-sh-closes-immediately-without-waiting-for-user-input">Why system(‘/bin/sh’) doesn’t work</a></p>
<table>
<thead>
<tr>
<th>compile with <code>-Og</code> or not</th>
<th>spawn shell in debugger or not</th>
<th>spawn shell outside debugger or not</th>
</tr>
</thead>
<tbody><tr>
<td>No</td>
<td><code>pwndbg</code>:Yes(align 16 needed, <code>ret</code> in ROP)</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td>vanilla <code>gdb</code> :NO</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td><code>gdb-peda</code>:Yes</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td><code>gdb-gef</code>:NO</td>
<td>Yes</td>
</tr>
<tr>
<td>Yes</td>
<td><code>pwndbg</code>:Yes(align 16 needed, <code>ret</code> in ROP)</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td>vanilla <code>gdb</code>:NO</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td><code>gdb-peda</code>:Yes</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td><code>gdb-gef</code>:NO</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>Change <code>pwndbg</code> assembly flavor : <code>set disassembly-flavor att</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg/issues/419">However, code browsing like vanilla gdb is still impossible in pwndbg</a></p>
<p><code>gdb-peda</code> and <code>gdb-gef</code> don’t support this, too.</p>
<hr>
<p>Typically, the program is fed with a string that contains the byte encoding of some executable code, called the <strong>exploit code</strong>, plus some extra bytes that overwrite the return address with <strong>a pointer to the exploit code</strong>. The effect of executing the ret instruction is then to jump to the exploit code.</p>
<ul>
<li>In one form of attack, the exploit code then <strong>uses a system call to start up a shell</strong> program, providing the attacker with a range of operating system functions.</li>
<li>In another form, the exploit code performs some otherwise <strong>unauthorized task</strong>, repairs the damage to the stack, and then executes ret a second time, <strong>causing an (apparently) normal return to the caller.</strong></li>
</ul>
<h5 id="Programming-tips"><a href="#Programming-tips" class="headerlink" title="Programming tips"></a>Programming tips</h5><p> Any interface to the external environment should be made “bulletproof” so that no behavior by an external agent can cause the system to misbehave.</p>
<h3 id="3-10-4-Thwarting-Buffer-Overflow-Attacks"><a href="#3-10-4-Thwarting-Buffer-Overflow-Attacks" class="headerlink" title="3.10.4 Thwarting Buffer Overflow Attacks"></a>3.10.4 Thwarting Buffer Overflow Attacks</h3><p><em>Buffer overflow attacks have become so pervasive and have caused so many problems with computer systems that modern compilers and operating systems have <strong>implemented mechanisms to make it more difficult to mount these attacks and to limit the ways by which an intruder can seize control of a system</strong> via a buffer overflow attack.</em></p>
<h5 id="Stack-Randomization"><a href="#Stack-Randomization" class="headerlink" title="Stack Randomization"></a>Stack Randomization</h5><p><em>In order to insert exploit code into a system, the attacker needs to inject both the code as well as a pointer to this code as part of the attack string. This requires knowing the stack address where the string will be located.</em></p>
<ul>
<li><p>Historically, the stack addresses for a program were highly predictable. For all systems running the same combination of program and operating system version, the stack locations were fairly stable across many machines. </p>
</li>
<li><p>The idea of stack randomization is to make the position of the stack vary from one run of a program to another</p>
<ul>
<li>This is implemented by allocating a random amount of space between 0 and n bytes on the stack at the start of a program, for example, by using the allocation function <code>alloca</code>, which allocates space for a specified number of bytes on the stack.</li>
<li> This allocated space is not used by the program, but it causes all subsequent stack locations to vary from one execution of a program to another. </li>
<li>The allocation range n needs to be large enough to get sufficient variations in the stack addresses, yet small enough that it does not waste too much space in the program</li>
</ul>
</li>
<li><p>a simple way to determine a “typical” stack address</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> local;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>, &amp;local);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Running the code 10,000 times on a Linux machine in 32-bit mode, the addresses ranged from 0xff7fc59c to 0xffffd09c, a range of around $2^{23}.$ Running in 64- bit mode on the newer machine, the addresses ranged from 0x7fff0001b698 to 0x7ffffffaa4a8, a range of nearly $2^{32}$.</li>
</ul>
</li>
<li><p>Stack randomization has become part of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a></p>
<p>With ASLR, different parts of the program, including program code, library code, stack, global variables, and heap data, are loaded into different regions of memory each time a program is run.</p>
</li>
<li><p>Overall, however, a persistent attacker can <strong>overcome randomization by brute force</strong>, repeatedly attempting attacks with different addresses.</p>
<ul>
<li>A common trick is to include a long sequence of <code>nop</code> instructions before the actual exploit code, aka “nop sled”</li>
<li>If we set up a 256-byte nop sled, then the randomization over n = $2^{23}$ can be cracked by enumerating $2^{15}$ = 32,768 starting addresses, which is entirely feasible for a determined attacker.</li>
</ul>
</li>
</ul>
<h4 id="Practice-Problem-3-47"><a href="#Practice-Problem-3-47" class="headerlink" title="Practice Problem 3.47"></a>Practice Problem 3.47</h4><blockquote>
<p>Running our stack-checking code 10,000 times on a system running Linux version 2.6.16, we obtained addresses ranging from a minimum of 0xffffb754 to a maximum of 0xffffd754.</p>
<p>A. What is the approximate range of addresses? </p>
<p>B. If we attempted a buffer overrun with a 128-byte nop sled, about how many attempts would it take to test all starting addresses?</p>
</blockquote>
<h4 id="My-solution-white-check-mark"><a href="#My-solution-white-check-mark" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apprange = math.log(<span class="number">0xffffd754</span> - <span class="number">0xffffb754</span> , <span class="number">2</span> )</span><br><span class="line"><span class="comment"># 13</span></span><br></pre></td></tr></table></figure>
<p>The approximate range of address is $2^{13}$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attemps = (<span class="number">0xffffd754</span> - <span class="number">0xffffb754</span>) / <span class="number">128</span></span><br><span class="line"><span class="comment"># 64</span></span><br></pre></td></tr></table></figure>
<p>It would take 64 attemps</p>
<h4 id="Solution-on-the-book"><a href="#Solution-on-the-book" class="headerlink" title="Solution on the book:"></a>Solution on the book:</h4><p>A 128-byte nop sled would cover $2^7$ addresses with each test, and so we would only require around $2^6$ = 64 attempts.</p>
<p>This example clearly shows that the degree of randomization in this version of Linux would provide only minimal deterrence against an overflow attack.</p>
<hr>
<h5 id="Stack-Corruption-Detection"><a href="#Stack-Corruption-Detection" class="headerlink" title="Stack Corruption Detection"></a>Stack Corruption Detection</h5><p><em>In C, there is no reliable way to prevent writing beyond the bounds of an array. Instead, the program can attempt to detect when such a write has occurred before it can have any harmful effects.</em></p>
<ul>
<li><p>The idea is to store a special canary value4 in the stack frame between any local buffer and the rest of the stack state</p>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/canary.png" alt="canary value"></p>
</li>
<li><p>This canary value, also referred to as a guard value, is generated randomly each time the program runs, and so there is no easy way for an attacker to determine what it is.</p>
</li>
<li><p>Before restoring the register state and returning from the function, the program checks if the canary has been altered by some operation of this function or one that it has called. If so, the program aborts with an error.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">	subq	$24, %rsp</span><br><span class="line">	movq	%fs:40, %rax		# get canary value and store it in %rax</span><br><span class="line">	movq	%rax, 8(%rsp)		# store canary value after return addr</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movl	$0, 4(%rsp)</span><br><span class="line">	leaq	4(%rsp), %rdx</span><br><span class="line">	leaq	.LC0(%rip), %rsi</span><br><span class="line">	movl	$1, %edi</span><br><span class="line">	call	__printf_chk@PLT</span><br><span class="line">	movq	8(%rsp), %rcx		# get canary value from stack</span><br><span class="line">	xorq	%fs:40, %rcx		# check if was modified</span><br><span class="line">	jne	.L4</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br><span class="line">	call	__stack_chk_fail@PLT # if check failed, abort execution</span><br></pre></td></tr></table></figure>
<p>The instruction argument <code>%fs:40</code> is an indication that the canary value is read from memory using segmented addressing, an addressing mechanism that dates back to the 80286 and is seldom found in programs running on modern systems. </p>
<p>By storing the canary in a special segment, it can be marked as “read only,” so that an attacker cannot overwrite the stored canary value.</p>
</li>
</ul>
<h4 id="Practice-Problem-3-48"><a href="#Practice-Problem-3-48" class="headerlink" title="Practice Problem 3.48"></a>Practice Problem 3.48</h4><blockquote>
<p>The functions <code>intlen</code>, <code>len</code>, and <code>iptoa</code> provide a very convoluted way to compute the number of decimal digits required to represent an integer. We will use this as a way to study some aspects of the gcc stack protector facility.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iptoa</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> val = *p;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intlen</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> v;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">12</span>];</span><br><span class="line">v = x;</span><br><span class="line">iptoa(buf, &amp;v);</span><br><span class="line"><span class="keyword">return</span> len(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following show portions of the code for <code>intlen</code>, compiled both with and without stack protector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># with stack protection on</span><br><span class="line">intlen:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, 24(%rsp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movq	%rdi, (%rsp)</span><br><span class="line">	movq	%rsp, %rsi</span><br><span class="line">	leaq	12(%rsp), %rbx</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	iptoa</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	len</span><br><span class="line">	movq	24(%rsp), %rdx</span><br><span class="line">	xorq	%fs:40, %rdx</span><br><span class="line">	jne	.L7</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br><span class="line">	call	__stack_chk_fail@PLT</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># with stack protection off</span><br><span class="line">intlen:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$32, %rsp</span><br><span class="line">	movq	%rdi, 24(%rsp)</span><br><span class="line">	leaq	24(%rsp), %rsi</span><br><span class="line">	leaq	12(%rsp), %rbx</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	iptoa</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	len</span><br><span class="line">	addq	$32, %rsp</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>A. For both versions: What are the positions in the stack frame for <code>buf</code>,<code> v</code>, and (when present) the canary value?</p>
<p>B. How does the rearranged ordering of the local variables in the protected code provide greater security against a buffer overrun attack?</p>
</blockquote>
<h4 id="My-solution-warning"><a href="#My-solution-warning" class="headerlink" title="My solution : :warning:"></a>My solution : :warning:</h4><p>A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># protected version:</span><br><span class="line">buf : leaq 12(%rsp)</span><br><span class="line">v	: leaq (%rsp)</span><br><span class="line">canary value : leaq 24(%rsp)</span><br><span class="line"># unprotected version:</span><br><span class="line">buf : leaq 12(%rsp)</span><br><span class="line">v	: 24(%rsp)</span><br></pre></td></tr></table></figure>
<p>B:</p>
<p>the canary value is just above the buf, providing a boundary check</p>
<h4 id="Solution-on-the-book-1"><a href="#Solution-on-the-book-1" class="headerlink" title="Solution on the book:"></a>Solution on the book:</h4><p>B:</p>
<p>In the protected code, local variable v is positioned closer to the top of the stack than buf, and so an overrun of buf will not corrupt the value of v.</p>
<hr>
<h5 id="Limiting-Executable-Code-Regions"><a href="#Limiting-Executable-Code-Regions" class="headerlink" title="Limiting Executable Code Regions"></a>Limiting Executable Code Regions</h5><p><em>A final step is to eliminate the ability of an attacker to insert executable code into a system. One method is to <strong>limit which memory regions hold executable code</strong></em></p>
<ul>
<li><p> The <strong>hardware</strong> supports different forms of <strong>memory protection</strong>, indicating the forms of access allowed by both user programs and the operating system kernel. </p>
</li>
<li><p>Many systems allow control over three forms of access: <code>r</code> <code>w</code> <code>x</code></p>
<p>Historically, the x86 architecture merged the read and execute access controls into a single 1-bit flag, so that any page marked as readable was also executable. </p>
</li>
<li><p>The stack had to be kept both readable and writable, and therefore the bytes on the <strong>stack were also executable</strong>. </p>
<ul>
<li>Various schemes were implemented to be able to limit some pages to being readable but not executable, but these generally introduced significant inefficiencies.</li>
</ul>
</li>
<li><p>More recently, AMD introduced an NX (for “no-execute”) bit into the memory protection for its 64-bit processors, separating the read and execute access modes, and Intel followed suit. </p>
<ul>
<li>With this feature, <strong>the stack can be marked as being readable and writable, but not executable</strong></li>
<li>And the checking of whether a page is executable is performed in hardware, with no penalty in efficiency</li>
</ul>
</li>
<li><p>However, “just-in-time” compilation techniques dynamically generate code for programs written in interpreted languages. So whether or not the run-time system can restrict the executable code to just that part generated by the compiler in creating the original program depends on the language and the operating system.</p>
</li>
<li><p>We can control it with <code>-z execstack</code> or <code>-z noexecstack</code> link options.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ pwn checksec can</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">$ pwn checksec cannot</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<h3 id="3-10-5-Supporting-Variable-Size-Stack-Frames"><a href="#3-10-5-Supporting-Variable-Size-Stack-Frames" class="headerlink" title="3.10.5 Supporting Variable-Size Stack Frames"></a>3.10.5 Supporting Variable-Size Stack Frames</h3></li>
</ul>
<p><em>Usually, the compiler can allocate stack space for a function in compiling stage. Some functions, however, require a variable amount of local storage.</em></p>
<p>This can occur, for example, when the function calls <code>alloca</code> or declare an array with variable size</p>
<p>To manage a variable-size stack frame, x86-64 code uses register <code>%rbp</code> to serve as a <strong>frame pointer</strong> (sometimes referred to as a base pointer, and hence the letters bp in <code>%rbp</code>).</p>
<p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vframe</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> idx, <span class="keyword">long</span> *q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">long</span> *p[n];</span><br><span class="line">p[<span class="number">0</span>] = &amp;i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">p[i] = q;</span><br><span class="line"><span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vframe:</span><br><span class="line">	pushq	%rbp			# save previous stack</span><br><span class="line">	movq	%rsp, %rbp		# make rbp point to current stack frame</span><br><span class="line">	subq	$16, %rsp		# allocate 16 bytes , s1</span><br><span class="line">	leaq	22(,%rdi,8), %rax	</span><br><span class="line">	andq	$-16, %rax</span><br><span class="line">	subq	%rax, %rsp		# s2</span><br><span class="line">	leaq	7(%rsp), %rax</span><br><span class="line">	shrq	$3, %rax</span><br><span class="line">	leaq	0(,%rax,8), %r8	# p</span><br><span class="line">	movq	%r8, %rcx</span><br><span class="line">	leaq	-8(%rbp), %r9	# r9 &#x3D; &amp;i</span><br><span class="line">	movq	%r9, 0(,%rax,8)	# p[0] &#x3D; &amp;i;</span><br><span class="line">	movq	$1, -8(%rbp)	# i &#x3D; 1</span><br><span class="line">	jmp	.L2</span><br><span class="line">.L3:</span><br><span class="line">	movq	%rdx, (%rcx,%rax,8) #*(p+i*8)&#x3D;q</span><br><span class="line">	addq	$1, -8(%rbp)	#i++</span><br><span class="line">.L2:</span><br><span class="line">	movq	-8(%rbp), %rax	#rax&#x3D;i</span><br><span class="line">	cmpq	%rax, %rdi #while(n&gt;i)</span><br><span class="line">	jg	.L3</span><br><span class="line">	movq	(%r8,%rsi,8), %rax</span><br><span class="line">	movq	(%rax), %rax</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/rbp.png" alt="frame pointer"></p>
<ul>
<li><p>it references fixed-length local variables, such as i, at offsets relative to <code>%rbp</code></p>
</li>
<li><p>At the end of the function, the frame pointer is restored to its previous value using the <code>leave</code> instruction.</p>
<p>This instruction takes no arguments. It is equivalent to executing the following two instructions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq %rbp, %rsp 	#Set stack pointer to beginning of frame</span><br><span class="line">popq %rbp 			#Restore saved %rbp and set stack ptr</span><br><span class="line">					#to end of caller’s frame</span><br></pre></td></tr></table></figure></li>
<li><p>In earlier versions of x86 code, the frame pointer was used with every function call. With x86-64 code, it is used only in cases where the stack frame may be of variable size</p>
</li>
</ul>
<h4 id="Practice-Problem-3-49"><a href="#Practice-Problem-3-49" class="headerlink" title="Practice Problem 3.49"></a>Practice Problem 3.49</h4><blockquote>
<p>In this problem, we will explore the logic behind the code where space is allocated for variable-size array p.</p>
<p> let us let $s_1$ denote the address of the stack pointer after executing the <code>subq</code> instruction at line 4.This instruction allocates the space for local variable i.</p>
<p>Let $s_2$ denote the value of the stack pointer after executing the subq instruction of line 7.This instruction allocates the storage for local array p. </p>
<p>Finally, let $p$ denote the value assigned to registers <code>%r8</code> and <code>%rcx</code> in the instructions of lines 10–11. Both of these registers are used to reference array p</p>
<p>Figure 3.44 diagrams the positions of the locations indicated by $s_1$,$ s_2$, and $p$. It also shows that there may be an offset of $e_2$ bytes between the values of $s_1$ and $p$. This space will not be used. There may also be an offset of $e_1$ bytes between the end of array p and the position indicated by $s_1$​</p>
<p>A. Explain, in mathematical terms, the logic in the computation of $s_2$​ on lines 5–7. Hint: Think about the bit-level representation of −16 and its effect in the <code>andq</code> instruction of line 6.</p>
<p>B. Explain, in mathematical terms, the logic in the computation of p on lines 8–10. Hint: You may want to refer to the discussion on division by powers of 2 in Section 2.3.7.</p>
<p>C. For the following values of n and s1, trace the execution of the code to determine what the resulting values would be for s2, p, e1, and e2.</p>
<table>
<thead>
<tr>
<th>n</th>
<th>s1</th>
<th>s2</th>
<th>p</th>
<th>e1</th>
<th>e2</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>2065</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>2064</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>D. What alignment properties does this code guarantee for the values of s2 and p?</p>
</blockquote>
<h4 id="My-solution-warning-1"><a href="#My-solution-warning-1" class="headerlink" title="My solution : :warning:"></a>My solution : :warning:</h4><p>A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaq	22(,%rdi,8), %rax	# rax &#x3D; 8*n + 22</span><br><span class="line">andq	$-16, %rax			# rax &#x3D; (8*n + 22) &amp; -16</span><br><span class="line">subq	%rax, %rsp			# rsp -&#x3D; (8*n + 22) &amp; -16</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp; <span class="number">-16</span> means ((<span class="number">8</span>*n+<span class="number">22</span>) &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">4</span>  , == ((<span class="number">8</span>*n+<span class="number">22</span>) / <span class="number">16</span> * <span class="number">16</span>)</span><br><span class="line">when n = <span class="number">2</span>k - <span class="number">1</span> is odd, the result is  <span class="number">8</span>(n+<span class="number">1</span>)</span><br><span class="line">when n = <span class="number">2</span>k is even, the result is <span class="number">8</span>n+<span class="number">16</span></span><br><span class="line">align the space to <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>B:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	leaq	7(%rsp), %rax		# rax &#x3D; rsp + 7</span><br><span class="line">	shrq	$3, %rax			# rax &#x3D; (rsp+7) &#x2F; 8</span><br><span class="line">	leaq	0(,%rax,8), %r8		# r8 &#x3D; ((rsp+7) &#x2F; 8) * 8</span><br><span class="line"># division for negative value</span><br><span class="line"># add bias (2^3-1) &#x3D; 7</span><br><span class="line"># divide 2^3 : (rax &gt;&gt; 3)</span><br><span class="line"># r8 &#x3D; rax &#x2F;&#x2F; 8 , round towards 0</span><br><span class="line"># division for positive value</span><br><span class="line"># round towards +infinty</span><br><span class="line"># finally multiple by 8</span><br></pre></td></tr></table></figure>
<p>C:</p>
<table>
<thead>
<tr>
<th>n</th>
<th>s1</th>
<th>s2</th>
<th>p</th>
<th>e1</th>
<th>e2</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>2065</td>
<td>2017</td>
<td>2024</td>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>2064</td>
<td>2000</td>
<td>2000</td>
<td>16</td>
<td>0</td>
</tr>
</tbody></table>
<p>$$<br>n = 5 , s_1 = 2065<br>$$</p>
<p>$$<br>s_2 = s_1 -(8\times 5 + 8)=2065 -48 = 2017<br>$$</p>
<p>$$<br>e_2 = p - s_2 = 7<br>$$</p>
<p>$$<br>e_ 1= s_1 - (s_2 + (8\times n)) = 1<br>$$</p>
<p>D:</p>
<p>Align to 8 for p, no alignment for s2</p>
<h4 id="Solution-on-the-book-2"><a href="#Solution-on-the-book-2" class="headerlink" title="Solution on the book :"></a>Solution on the book :</h4><p>A. The leaq instruction of line 5 computes the value $8n + 22$, which is then rounded down to the nearest multiple of 16 by the andq instruction of line 6. The resulting value will be $8n + 8$ when n is odd and $8n + 16$ when n is even, and this value is subtracted from s1 to give s2.</p>
<p>B. The three instructions in this sequence round s2 up to the nearest multiple of 8. They make use of the combination of biasing and shifting that we saw for dividing by a power of 2 in Section 2.3.7.</p>
<p>D. We can see that s2 is computed in a way that preserves whatever offset s1 has with the nearest multiple of 16. We can also see that p will be aligned on a multiple of 8, as is recommended for an array of 8-byte elements.</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="keyword">int</span> twodimensions [N][N];</span><br><span class="line"><span class="comment">//type(twodimensions) is not int** !!</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr [N];</span><br><span class="line">arr * p = twodimensions; <span class="comment">//this is correct, *(++p) == twodimensions[1]</span></span><br></pre></td></tr></table></figure>
<p>stick to pointer arithmetic principle when you interact with array.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr a1 = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">arr a2 = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">arr a3 = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">arr * pointers [<span class="number">3</span>] = &#123; a1 , a2 , a3 &#125;; <span class="comment">// wrong , a1 is converted to arr* from int*</span></span><br><span class="line"><span class="keyword">int</span> * ps  [<span class="number">3</span>]= &#123; a1 , a2 , a3 &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span> , pointers[<span class="number">0</span>]+<span class="number">1</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span> , ps[<span class="number">0</span>]+<span class="number">1</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span> , a1+<span class="number">1</span>); </span><br></pre></td></tr></table></figure>
<h2 id="3-11-Floating-Point-Code"><a href="#3-11-Floating-Point-Code" class="headerlink" title="3.11 Floating-Point Code"></a>3.11 Floating-Point Code</h2><p><em>The floating-point architecture for a processor consists of the different aspects that affect <strong>how programs operating on floating-point data are mapped onto the machine</strong>, including</em></p>
<ul>
<li>How floating-point values are <strong>stored and accessed</strong></li>
<li>The <strong>instructions</strong> that operate on floating-point data.</li>
<li>The conventions used for passing floating-point values as arguments to functions and for returning them as results.</li>
<li>The conventions for how registers are preserved during function calls</li>
</ul>
<h5 id="Historical-view"><a href="#Historical-view" class="headerlink" title="Historical view"></a>Historical view</h5><ul>
<li>in 1997, both Intel and AMD have incorporated successive generations of <strong>media instructions</strong> to support graphics and image processing.<ul>
<li>These instructions originally focused on SIMD(Simple Instruction Multiple Data), allowing the same operation is performed on a number of different data values in parallel</li>
</ul>
</li>
<li>Over the years, there has been a progression of these extensions<ul>
<li>The name has changed from MMX to SSE(Stream SIMD Extension), and most recently, AVX(Advanced Vector Extension)</li>
<li>Each of these extensions manages data in sets of registers</li>
<li>They have different register names and register sizes</li>
</ul>
</li>
<li>All processors capable of executing x86-64 code support SSE2 or higher, and hence x86-64 floating point is based on SSE or AVX, including conventions for passing procedure arguments and return values<ul>
<li>Our presentation is based on AVX2</li>
<li>Gcc will generate AVX2 code when given the command-line parameter <code>-mavx2</code></li>
</ul>
</li>
</ul>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/ymm.png" alt="registers"></p>
<ul>
<li><p>the AVX floating-point architecture allows data to be stored in 16 YMM registers, named <code>%ymm0</code>–<code>%ymm15</code>.</p>
</li>
<li><p>Each YMM register is 256 bits (32 bytes) long.</p>
</li>
<li><p>When operating on <strong>scalar data</strong>, these registers only hold floating-point data, and <strong>only the low-order 32 bits (for float) or 64 bits (for double) are used.</strong> </p>
<p><strong>(Set unused space to 0 in register but only change 32 or 64 bits in memory !)</strong></p>
</li>
</ul>
<h3 id="3-11-1-Floating-Point-Movement-and-Conversion-Operations"><a href="#3-11-1-Floating-Point-Movement-and-Conversion-Operations" class="headerlink" title="3.11.1 Floating-Point Movement and Conversion Operations"></a>3.11.1 Floating-Point Movement and Conversion Operations</h3><p><img src="/2021/08/09/CSAPP/Ch3PartIV/vmov.png" alt="mov instructions"></p>
<ul>
<li><p>Memory references are specified in the same way as for the integer <code>mov</code> instructions, with all of the different possible combinations of displacement, base register, index register, and scaling factor</p>
</li>
<li><p>Gcc uses the scalar movement operations only to transfer data from memory to an XMM register or from an XMM register to memory.</p>
<p>For transferring data between two XMM registers, it uses one of two different instructions for copying the entire contents of one XMM register to another</p>
<p><code>vmovaps</code> for single precision, <code>vmovapd</code> for double precision</p>
</li>
<li><p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">float_mov</span><span class="params">(<span class="keyword">float</span> v1, <span class="keyword">float</span> *src, <span class="keyword">float</span> *dst)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> v2 = *src;</span><br><span class="line">*dst = v1;</span><br><span class="line"><span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc float.c -Og -mavx2 -S -o  float.s &amp;&amp; ./wash float.s &amp;&amp; cat clean_float.s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># v1 in %xmm0, src in %rdi, dst in %rsi</span><br><span class="line">float_mov:</span><br><span class="line">	vmovss	(%rdi), %xmm1</span><br><span class="line">	vmovss	%xmm0, (%rsi)</span><br><span class="line">	vmovaps	%xmm1, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/convert.png" alt="conversion instructions"></p>
</li>
</ul>
<p>When converting floating-point values to integers, they perform <strong>truncation, rounding values toward zero</strong></p>
<p>For example</p>
<ul>
<li><code>float</code> to <code>int</code> : <code>vcvttss2si %xmm0, %rdx</code></li>
<li><code>float</code> to <code>double</code> : <code>vcvtss2sd %xmm0,%xmm0,%xmm0 </code></li>
</ul>
<p>(There are situations where gcc generate weird code for conversion, if this happens, STFW or check page 334)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Conversion from single to double precision</span><br><span class="line">vunpcklps %xmm0, %xmm0, %xmm0 	#Replicate first vector element</span><br><span class="line">vcvtps2pd %xmm0, %xmm0 			#Convert two vector elements to double</span><br></pre></td></tr></table></figure>
<h4 id="Practice-Problem-3-50"><a href="#Practice-Problem-3-50" class="headerlink" title="Practice Problem 3.50"></a>Practice Problem 3.50</h4><blockquote>
<p>For the following C code, the expressions <code>val1</code> to<code>val4</code> all map to the program values <code>i</code>,<code> f</code>,<code> d</code>, and <code>l</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fcvt2</span><span class="params">(<span class="keyword">int</span> *ip, <span class="keyword">float</span> *fp, <span class="keyword">double</span> *dp, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = *ip; <span class="keyword">float</span> f = *fp; <span class="keyword">double</span> d = *dp;</span><br><span class="line">*ip = (<span class="keyword">int</span>) val1;</span><br><span class="line">*fp = (<span class="keyword">float</span>) val2;</span><br><span class="line">*dp = (<span class="keyword">double</span>) val3;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>) val4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Determine the mapping, based on the following x86-64 code for the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fcvt2:</span><br><span class="line">    movl (%rdi), %eax</span><br><span class="line">    vmovss (%rsi), %xmm0</span><br><span class="line">    vcvttsd2si (%rdx), %r8d</span><br><span class="line">    movl %r8d, (%rdi)</span><br><span class="line">    vcvtsi2ss %eax, %xmm1, %xmm1</span><br><span class="line">    vmovss %xmm1, (%rsi)</span><br><span class="line">    vcvtsi2sdq %rcx, %xmm1, %xmm1</span><br><span class="line">    vmovsd %xmm1, (%rdx)</span><br><span class="line">    vunpcklps %xmm0, %xmm0, %xmm0</span><br><span class="line">    vcvtps2pd %xmm0, %xmm0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="My-solution-white-check-mark-1"><a href="#My-solution-white-check-mark-1" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># double fcvt2(int *ip, float *fp, double *dp, long l)</span><br><span class="line">fcvt2:        </span><br><span class="line">    movl (%rdi), %eax       # eax &#x3D; *ip</span><br><span class="line">    vmovss (%rsi), %xmm0    # xmm0 &#x3D; *fp </span><br><span class="line">    vcvttsd2si (%rdx), %r8d # r8d &#x3D; (int)*dp</span><br><span class="line">    movl %r8d, (%rdi)       # *ip &#x3D; (int)*dp </span><br><span class="line">    vcvtsi2ss %eax, %xmm1, %xmm1   # xmm1 &#x3D; (float)*ip </span><br><span class="line">    vmovss %xmm1, (%rsi)           # *fp &#x3D; (float)*ip</span><br><span class="line">    vcvtsi2sdq %rcx, %xmm1, %xmm1  # xmm1 &#x3D; (double)l  </span><br><span class="line">    vmovsd %xmm1, (%rdx)           # *dp &#x3D; (double)l</span><br><span class="line">    vunpcklps %xmm0, %xmm0, %xmm0  # ret &#x3D; xmm0 &#x3D; (double)*fp</span><br><span class="line">    vcvtps2pd %xmm0, %xmm0         </span><br><span class="line">    ret        </span><br><span class="line"># val1 &#x3D; *dp</span><br><span class="line"># val2 &#x3D; *ip</span><br><span class="line"># val3 &#x3D; l</span><br><span class="line"># val4 &#x3D; *fp</span><br></pre></td></tr></table></figure>
<h4 id="Practice-Problem-3-51"><a href="#Practice-Problem-3-51" class="headerlink" title="Practice Problem 3.51"></a>Practice Problem 3.51</h4><blockquote>
<p>The following C function converts an argument of type <code>src_t</code> to a return value of type <code>dst_t</code>, where these two types are defined using <code>typedef</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dest_t</span> <span class="title">cvt</span><span class="params">(<span class="keyword">src_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">dest_t</span> y = (<span class="keyword">dest_t</span>) x;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For execution on x86-64, assume that argument x is either in <code>%xmm0</code> or in the appropriately named portion of register <code>%rdi</code>. One or two instructions are to be used to perform the type conversion and to copy the value to the appropriately named portion of register <code>%rax</code> or <code>%xmm0</code> . Show the instruction(s), including the source and destination registers.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tx 		Ty 		<span class="title">Instruction</span><span class="params">(s)</span></span></span><br><span class="line">long 	double 	vcvtsi2sdq %rdi, %xmm0</span><br><span class="line"><span class="keyword">double</span> 	<span class="keyword">int</span></span><br><span class="line"><span class="keyword">double</span> 	<span class="keyword">float</span></span><br><span class="line"><span class="keyword">long</span> 	<span class="keyword">float</span></span><br><span class="line"><span class="keyword">float</span> 	<span class="keyword">long</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="My-solution-white-check-mark-2"><a href="#My-solution-white-check-mark-2" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Tx 		Ty 		<span class="title">Instruction</span><span class="params">(s)</span></span></span><br><span class="line">long 	double 	vcvtsi2sdq %rdi,%xmm0, %xmm0</span><br><span class="line"><span class="keyword">double</span> 	<span class="keyword">int</span>		vcvttsd2si  %xmm0,%eax</span><br><span class="line">double 	float	vcvtsd2ss  (%rdi), %xmm0, %xmm0</span><br><span class="line"><span class="keyword">long</span> 	<span class="keyword">float</span>	vcvtsi2ssq %rdi,%xmm0, %xmm0</span><br><span class="line"><span class="keyword">float</span> 	<span class="keyword">long</span>	vcvttss2siq %xmm0,%rax</span><br></pre></td></tr></table></figure>
<h3 id="3-11-2-Floating-Point-Code-in-Procedures"><a href="#3-11-2-Floating-Point-Code-in-Procedures" class="headerlink" title="3.11.2 Floating-Point Code in Procedures"></a>3.11.2 Floating-Point Code in Procedures</h3><p>the following conventions are observed:</p>
<ul>
<li>Up to eight floating-point arguments can be passed in XMM registers <code>%xmm0</code> to <code>%xmm7</code>. These registers are used in the order the arguments are listed. Additional floating-point arguments can be passed on the stack.</li>
<li>A function that returns a floating-point value does so in register <code>%xmm0</code>.</li>
<li>All XMM registers are caller saved. The callee may overwrite any of these registers without first saving it.</li>
</ul>
<h4 id="Practice-Problem-3-52"><a href="#Practice-Problem-3-52" class="headerlink" title="Practice Problem 3.52"></a>Practice Problem 3.52</h4><blockquote>
<p>For each of the following function declarations, determine the register assignments for the arguments:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="function"><span class="keyword">double</span> <span class="title">g1</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">long</span> b, <span class="keyword">float</span> c, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line">B. <span class="function"><span class="keyword">double</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> *b, <span class="keyword">float</span> *c, <span class="keyword">long</span> d)</span></span>;</span><br><span class="line">C. <span class="function"><span class="keyword">double</span> <span class="title">g3</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d)</span></span>;</span><br><span class="line">D. <span class="function"><span class="keyword">double</span> <span class="title">g4</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">int</span> *b, <span class="keyword">float</span> c, <span class="keyword">double</span> d)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="My-solution-white-check-mark-3"><a href="#My-solution-white-check-mark-3" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A. <span class="function"><span class="keyword">double</span> <span class="title">g1</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">long</span> b, <span class="keyword">float</span> c, <span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="comment">//a in %xmm0, b in %rdi , c in %xmm1 , d in %esi</span></span><br><span class="line">B. <span class="function"><span class="keyword">double</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> *b, <span class="keyword">float</span> *c, <span class="keyword">long</span> d)</span></span>;</span><br><span class="line"><span class="comment">// a in %edi , b in %rsi , c in %rdx , d in %rcx</span></span><br><span class="line">C. <span class="function"><span class="keyword">double</span> <span class="title">g3</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> b, <span class="keyword">int</span> c, <span class="keyword">float</span> d)</span></span>;</span><br><span class="line"><span class="comment">// a in %rdi , b in %xmm0 , c in %esi , d in %xmm1</span></span><br><span class="line">D. <span class="function"><span class="keyword">double</span> <span class="title">g4</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">int</span> *b, <span class="keyword">float</span> c, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="comment">// a in %xmm0 , b in %rdi , c in %xmm1 , d in %xmm2</span></span><br></pre></td></tr></table></figure>
<h3 id="3-11-3-Floating-Point-Arithmetic-Operations"><a href="#3-11-3-Floating-Point-Arithmetic-Operations" class="headerlink" title="3.11.3 Floating-Point Arithmetic Operations"></a>3.11.3 Floating-Point Arithmetic Operations</h3><p><img src="/2021/08/09/CSAPP/Ch3PartIV/floatarith.png" alt="float point arithmetic instructions"></p>
<ul>
<li>Each has either one (S1) or two (S1, S2) source operands and a destination operand D.</li>
<li>The first source operand S1 can be either an XMM register or a memory location. The second source operand must be a XMM register</li>
<li>Each operation has an instruction for single precision and an instruction for double precision. </li>
</ul>
<p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">float</span> x, <span class="keyword">double</span> b, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*x - b/i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">funct:</span><br><span class="line">	vcvtss2sd	%xmm1, %xmm1, %xmm1	# x &#x3D; (double)x</span><br><span class="line">	vmulsd	%xmm0, %xmm1, %xmm0		# a &#x3D; a*x</span><br><span class="line">	vxorpd	%xmm1, %xmm1, %xmm1		# x &#x3D; 0</span><br><span class="line">	vcvtsi2sd	%edi, %xmm1, %xmm1	# x &#x3D; (double)i</span><br><span class="line">	vdivsd	%xmm1, %xmm2, %xmm2		# b &#x3D; b&#x2F;x</span><br><span class="line">	vsubsd	%xmm2, %xmm0, %xmm0		# return a-b</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h4 id="Practice-Problem-3-53"><a href="#Practice-Problem-3-53" class="headerlink" title="Practice Problem 3.53"></a>Practice Problem 3.53</h4><blockquote>
<p>For the following C function, the types of the four arguments are defined by <code>typedef</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct1</span><span class="params">(<span class="keyword">arg1_t</span> p, <span class="keyword">arg2_t</span> q, <span class="keyword">arg3_t</span> r, <span class="keyword">arg4_t</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p/(q+r) - s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When compiled, gcc generates the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)</span><br><span class="line">funct1:</span><br><span class="line"> vcvtsi2ssq %rsi, %xmm2, %xmm2</span><br><span class="line"> vaddss %xmm0, %xmm2, %xmm0</span><br><span class="line"> vcvtsi2ss %edi, %xmm2, %xmm2</span><br><span class="line"> vdivss %xmm0, %xmm2, %xmm0</span><br><span class="line"> vunpcklps %xmm0, %xmm0, %xmm0</span><br><span class="line"> vcvtps2pd %xmm0, %xmm0</span><br><span class="line"> vsubsd %xmm1, %xmm0, %xmm0</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>Determine the possible combinations of types of the four arguments (there may be more than one).</p>
</blockquote>
<h4 id="My-solution-white-check-mark-4"><a href="#My-solution-white-check-mark-4" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)</span><br><span class="line">funct1:</span><br><span class="line"> vcvtsi2ssq %rsi, %xmm2, %xmm2	# xmm2 &#x3D; (float)rsi  q or r in %rsi, long</span><br><span class="line"> vaddss %xmm0, %xmm2, %xmm0		# xmm0 &#x3D; q+r	q or r in %xmm0, float</span><br><span class="line"> vcvtsi2ss %edi, %xmm2, %xmm2	# xmm2 &#x3D; (float)edi</span><br><span class="line"> vdivss %xmm0, %xmm2, %xmm0		# xmm0 &#x3D; xmm2&#x2F;xmm0 &#x3D; p&#x2F;xmm0</span><br><span class="line"> vunpcklps %xmm0, %xmm0, %xmm0	# xmm0 &#x3D; (double)xmm0</span><br><span class="line"> vcvtps2pd %xmm0, %xmm0</span><br><span class="line"> vsubsd %xmm1, %xmm0, %xmm0		# xmm0 &#x3D; xmm0 - xmm1 , s in xmm1</span><br><span class="line"> ret</span><br><span class="line"># arg1_t is int</span><br><span class="line"># arg4_t is double</span><br><span class="line"># arg2_t is long or float</span><br><span class="line"># arg3_t is float or long</span><br></pre></td></tr></table></figure>
<h4 id="Practice-Problem-3-54"><a href="#Practice-Problem-3-54" class="headerlink" title="Practice Problem 3.54"></a>Practice Problem 3.54</h4><blockquote>
<p>Function <code>funct2</code> has the following prototype:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct2</span><span class="params">(<span class="keyword">double</span> w, <span class="keyword">int</span> x, <span class="keyword">float</span> y, <span class="keyword">long</span> z)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Gcc generates the following code for the function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#double funct2(double w, int x, float y, long z)</span><br><span class="line">#w in %xmm0, x in %edi, y in %xmm1, z in %rsi</span><br><span class="line">funct2:</span><br><span class="line"> vcvtsi2ss %edi, %xmm2, %xmm2</span><br><span class="line"> vmulss %xmm1, %xmm2, %xmm1</span><br><span class="line"> vunpcklps %xmm1, %xmm1, %xmm1</span><br><span class="line"> vcvtps2pd %xmm1, %xmm2</span><br><span class="line"> vcvtsi2sdq %rsi, %xmm1, %xmm1</span><br><span class="line"> vdivsd %xmm1, %xmm0, %xmm0</span><br><span class="line"> vsubsd %xmm0, %xmm2, %xmm0</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>Write a C version of funct2.</p>
</blockquote>
<h4 id="My-solution-1"><a href="#My-solution-1" class="headerlink" title="My solution :"></a>My solution :</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#double funct2(double w, int x, float y, long z)</span><br><span class="line">#w in %xmm0, x in %edi, y in %xmm1, z in %rsi</span><br><span class="line">funct2:</span><br><span class="line"> vcvtsi2ss %edi, %xmm2, %xmm2	# xmm2 &#x3D; (float)x</span><br><span class="line"> vmulss %xmm1, %xmm2, %xmm1		# xmm1 &#x3D; xmm1 * xmm2	y &#x3D; y*x</span><br><span class="line"> vunpcklps %xmm1, %xmm1, %xmm1	# xmm2 &#x3D; (double)y</span><br><span class="line"> vcvtps2pd %xmm1, %xmm2</span><br><span class="line"> vcvtsi2sdq %rsi, %xmm1, %xmm1	# xmm1 &#x3D; (double)z</span><br><span class="line"> vdivsd %xmm1, %xmm0, %xmm0		# xmm0 &#x3D; xmm0 &#x2F; xmm1 	w &#x3D; w&#x2F;z</span><br><span class="line"> vsubsd %xmm0, %xmm2, %xmm0		# res &#x3D; xmm2 - xmm0		return y-w&#x2F;z</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct2</span><span class="params">(<span class="keyword">double</span> w, <span class="keyword">int</span> x, <span class="keyword">float</span> y, <span class="keyword">long</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y*x-w/z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-4-Defining-and-Using-Floating-Point-Constants"><a href="#3-11-4-Defining-and-Using-Floating-Point-Constants" class="headerlink" title="3.11.4 Defining and Using Floating-Point Constants"></a>3.11.4 Defining and Using Floating-Point Constants</h3><p><em>Unlike integer arithmetic operations, AVX floating-point operations cannot have immediate values as operands. Instead, <strong>the compiler must allocate and initialize storage for any constant values</strong> .The code then reads the values from memory. .</em></p>
<p>For example</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cel2fahr</span><span class="params">(<span class="keyword">double</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.8</span> * temp + <span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">	vmulsd	.LC0(%rip), %xmm0, %xmm0</span><br><span class="line">	vaddsd	.LC1(%rip), %xmm0, %xmm0</span><br><span class="line">	ret</span><br><span class="line">.LC0:</span><br><span class="line">	.long	3435973837</span><br><span class="line">	.long	1073532108</span><br><span class="line">	.align 8</span><br><span class="line">.LC1:</span><br><span class="line">	.long	0</span><br><span class="line">	.long	1077936128</span><br></pre></td></tr></table></figure>
<p>Little endian mechine:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> unpack</span><br><span class="line">highorder = <span class="built_in">hex</span>(<span class="number">1073532108</span>)[<span class="number">2</span>:]</span><br><span class="line">loworder = <span class="built_in">hex</span>(<span class="number">3435973837</span>)[<span class="number">2</span>:]</span><br><span class="line">hexs = highorder + loworder</span><br><span class="line">buf = <span class="built_in">int</span>(hexs , <span class="number">16</span>).to_bytes(<span class="number">8</span>,<span class="string">&#x27;little&#x27;</span>,signed=<span class="literal">True</span>)</span><br><span class="line">tp = unpack(<span class="string">&#x27;d&#x27;</span> , buf)</span><br><span class="line">print(tp[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 1.8</span></span><br></pre></td></tr></table></figure>
<h4 id="Practice-Problem-3-55"><a href="#Practice-Problem-3-55" class="headerlink" title="Practice Problem 3.55"></a>Practice Problem 3.55</h4><blockquote>
<p>Show how the numbers declared at label .LC1 encode the number 32.0.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">highorder = <span class="built_in">hex</span>(<span class="number">1077936128</span>)[<span class="number">2</span>:]</span><br><span class="line">loworder = <span class="built_in">hex</span>(<span class="number">0</span>)[<span class="number">2</span>:] * <span class="number">8</span></span><br><span class="line"><span class="comment"># 32.0</span></span><br></pre></td></tr></table></figure>
<h3 id="3-11-5-Using-Bitwise-Operations-in-Floating-Point-Code"><a href="#3-11-5-Using-Bitwise-Operations-in-Floating-Point-Code" class="headerlink" title="3.11.5 Using Bitwise Operations in Floating-Point Code"></a>3.11.5 Using Bitwise Operations in Floating-Point Code</h3><p><img src="/2021/08/09/CSAPP/Ch3PartIV/bitwise.png" alt="bitwise instructions"></p>
<p>These operations all act on packed data, meaning that they <strong>update the entire destination XMM register</strong>, applying the bitwise operation to all the data in the two source registers. </p>
<h4 id="Practice-Problem-3-56"><a href="#Practice-Problem-3-56" class="headerlink" title="Practice Problem 3.56"></a>Practice Problem 3.56</h4><blockquote>
<p>Consider the following C function, where <code>EXPR</code> is a macro defined with <code>#define</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simplefun</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> EXPR(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Below, we show the AVX2 code generated for different definitions of <code>EXPR</code>, where value x is held in <code>%xmm0</code>. All of them correspond to some useful operation on floating-point values. Identify what the operations are. Your answers will require you to understand the bit patterns of the constant words being retrieved from memory.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># A</span><br><span class="line">	vmovsd .LC1(%rip), %xmm1        </span><br><span class="line">    vandpd %xmm1, %xmm0, %xmm0    </span><br><span class="line">.LC1:                   </span><br><span class="line">    .long 4294967295    </span><br><span class="line">    .long 2147483647    </span><br><span class="line">    .long 0             </span><br><span class="line">    .long 0</span><br><span class="line"># B</span><br><span class="line">	vxorpd %xmm0, %xmm0, %xmm0</span><br><span class="line"># C</span><br><span class="line">    vmovsd .LC2(%rip), %xmm1        </span><br><span class="line">    vxorpd %xmm1, %xmm0, %xmm0</span><br><span class="line">.LC2:    </span><br><span class="line">    .long 0</span><br><span class="line">    .long -2147483648</span><br><span class="line">    .long 0</span><br><span class="line">    .long 0</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="My-solution-2"><a href="#My-solution-2" class="headerlink" title="My solution:"></a>My solution:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># A</span><br><span class="line">	vmovsd .LC1(%rip), %xmm1  		# xmm1 &#x3D;  011111111...111     </span><br><span class="line">    vandpd %xmm1, %xmm0, %xmm0    	# xmm0 &#x3D; xmm0 &amp; xmm1</span><br><span class="line">.LC1:                   </span><br><span class="line">    .long 4294967295    </span><br><span class="line">    .long 2147483647    </span><br><span class="line">    .long 0             </span><br><span class="line">    .long 0</span><br><span class="line"># B</span><br><span class="line">	vxorpd %xmm0, %xmm0, %xmm0	# xmm0 &#x3D; xmm0 ^ xmm0 &#x3D; 0</span><br><span class="line"># C</span><br><span class="line">    vmovsd .LC2(%rip), %xmm1   	# xmm1 &#x3D; 10000..000</span><br><span class="line">    vxorpd %xmm1, %xmm0, %xmm0	# xmm0 &#x3D; xmm1 ^ xmm0</span><br><span class="line">.LC2:    </span><br><span class="line">    .long 0</span><br><span class="line">    .long -2147483648</span><br><span class="line">    .long 0</span><br><span class="line">    .long 0</span><br></pre></td></tr></table></figure>
<h4 id="Solution-on-the-book-3"><a href="#Solution-on-the-book-3" class="headerlink" title="Solution on the book"></a>Solution on the book</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPR(x) fabs(x)</span></span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPR(x) 0.0</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPR(x) -x</span></span><br></pre></td></tr></table></figure>
<h3 id="3-11-6-Floating-Point-Comparison-Operations"><a href="#3-11-6-Floating-Point-Comparison-Operations" class="headerlink" title="3.11.6 Floating-Point Comparison Operations"></a>3.11.6 Floating-Point Comparison Operations</h3><p><img src="/2021/08/09/CSAPP/Ch3PartIV/ucmp.png" alt="cmp instructions"></p>
<p>(<strong>Instructions are <code>vucomiss</code> and <code>vucomisd</code></strong>)</p>
<p><em>The floating-point comparison instructions set three condition codes: the zero flag ZF, the carry flag CF, and the parity flag PF.</em></p>
<ul>
<li>The parity flag PF:<ul>
<li>For integer arithmetic and logical operation, if the least significant byte has even parity (i.e., an even number of ones in the byte) the flag will be 1.</li>
<li>For floating-point comparisons, the flag is set when <strong>either operand is NaN</strong></li>
<li>when operate with float point number, if PF is set, the comparison will fail.</li>
</ul>
</li>
</ul>
<p><img src="/2021/08/09/CSAPP/Ch3PartIV/conditions.png" alt="comparison conditions"></p>
<ul>
<li>The unordered case occurs when either operand is NaN.<ul>
<li> Commonly, the <code>jp</code> (for “jump on parity”) instruction is used to conditionally jump when a floating-point comparison yields an unordered result.</li>
</ul>
</li>
<li>Other situations are like unsigned comparison<ul>
<li>ZF is set when the two operands are equal</li>
<li>CF is set when S2 &lt; S1</li>
<li>Instructions such as <code>ja</code> and <code>jb</code> are used to conditionally jump on various combinations of these flags.</li>
</ul>
</li>
</ul>
<h4 id="Practice-Problem-3-57"><a href="#Practice-Problem-3-57" class="headerlink" title="Practice Problem 3.57"></a>Practice Problem 3.57</h4><blockquote>
<p>Function <code>funct3</code> has the following prototype:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct3</span><span class="params">(<span class="keyword">int</span> *ap, <span class="keyword">double</span> b, <span class="keyword">long</span> c, <span class="keyword">float</span> *dp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>For this function, gcc generates the following code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">funct3:</span><br><span class="line">	vmovss	(%rdx), %xmm1</span><br><span class="line">	vxorpd	%xmm2, %xmm2, %xmm2</span><br><span class="line">	vcvtsi2sd	(%rdi), %xmm2, %xmm2</span><br><span class="line">	vucomisd	%xmm2, %xmm0</span><br><span class="line">	ja	.L7</span><br><span class="line">	vaddss	%xmm1, %xmm1, %xmm1</span><br><span class="line">	vxorps	%xmm0, %xmm0, %xmm0</span><br><span class="line">	vcvtsi2ssq	%rsi, %xmm0, %xmm0</span><br><span class="line">	vaddss	%xmm1, %xmm0, %xmm0</span><br><span class="line">	vcvtss2sd	%xmm0, %xmm0, %xmm0</span><br><span class="line">	ret</span><br><span class="line">.L7:</span><br><span class="line">	vxorps	%xmm0, %xmm0, %xmm0</span><br><span class="line">	vcvtsi2ssq	%rsi, %xmm0, %xmm0</span><br><span class="line">	vmulss	%xmm1, %xmm0, %xmm0</span><br><span class="line">	vcvtss2sd	%xmm0, %xmm0, %xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>Write a C version of <code>funct3</code>.</p>
</blockquote>
<h4 id="My-solution-white-check-mark-5"><a href="#My-solution-white-check-mark-5" class="headerlink" title="My solution: :white_check_mark:"></a>My solution: :white_check_mark:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># double funct3(int *ap, double b, long c, float *dp);</span><br><span class="line">funct3:</span><br><span class="line">	vmovss	(%rdx), %xmm1			# xmm1 &#x3D; *dp		</span><br><span class="line">	vxorpd	%xmm2, %xmm2, %xmm2		# xmm2 &#x3D; 0.0</span><br><span class="line">	vcvtsi2sd	(%rdi), %xmm2, %xmm2# xmm2 &#x3D; (double)*ap</span><br><span class="line">	vucomisd	%xmm2, %xmm0		# if (xmm0 &gt; xmm2) goto L7;</span><br><span class="line">	ja	.L7</span><br><span class="line">	vaddss	%xmm1, %xmm1, %xmm1		# xmm1 &#x3D; xmm1 + xmm1</span><br><span class="line">	vxorps	%xmm0, %xmm0, %xmm0		# xmm0 &#x3D; 0.0</span><br><span class="line">	vcvtsi2ssq	%rsi, %xmm0, %xmm0	# xmm0 &#x3D; (float)c</span><br><span class="line">	vaddss	%xmm1, %xmm0, %xmm0		# xmm0 &#x3D; xmm0 + xmm1</span><br><span class="line">	vcvtss2sd	%xmm0, %xmm0, %xmm0	# xmm0 &#x3D; (double)xmm0</span><br><span class="line">	ret</span><br><span class="line">.L7:</span><br><span class="line">	vxorps	%xmm0, %xmm0, %xmm0		# xmm0 &#x3D; 0.0</span><br><span class="line">	vcvtsi2ssq	%rsi, %xmm0, %xmm0	# xmm0 &#x3D; (float)c</span><br><span class="line">	vmulss	%xmm1, %xmm0, %xmm0		# xmm0 &#x3D; xmm0 * xmm1</span><br><span class="line">	vcvtss2sd	%xmm0, %xmm0, %xmm0	# xmm0 &#x3D; (double)xmm0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">funct3</span><span class="params">(<span class="keyword">int</span> *ap, <span class="keyword">double</span> b, <span class="keyword">long</span> c, <span class="keyword">float</span> *dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> d = *dp;</span><br><span class="line">    <span class="keyword">double</span> a = (<span class="keyword">double</span>)*ap;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(c*d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> (<span class="keyword">double</span>)(c+<span class="number">2</span>*d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-7-Observations-about-Floating-Point-Code"><a href="#3-11-7-Observations-about-Floating-Point-Code" class="headerlink" title="3.11.7 Observations about Floating-Point Code"></a>3.11.7 Observations about Floating-Point Code</h3><ul>
<li><p>AVX2 code involves many more different instructions and formats than is usually seen with functions that perform only integer arithmetic.</p>
</li>
<li><p><em>AVX2 also has the potential to make computations run faster by performing parallel operations on packed data.</em></p>
<p>See Web Aside opt:simd on page 582 to see how this can be done.</p>
</li>
</ul>
<h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li><p>compiling C++ is very similar to compiling C. </p>
<p>In fact, early implementations of C++ first performed a source-to-source conversion from C++ to C and generated object code by running a C compiler on the result</p>
</li>
<li><p>Java is implemented in an entirely different fashion. </p>
<p>The object code of Java is a special binary representation known as Java byte code.</p>
</li>
<li><p>check stack memory limit :</p>
<ul>
<li><code>csh</code> or <code>zsh</code> : <code>limit</code></li>
<li><code>bash</code> : <code>ulimit -a</code></li>
<li>use <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/alloca.3.html">alloca</a> function to allocate space on stack, but if no available space remains, the behavior will be undefined </li>
</ul>
</li>
<li><p>dangerous functions :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gets()	<span class="comment">//use fgets, please</span></span><br><span class="line"><span class="built_in">fscanf</span>(),<span class="built_in">sscanf</span>(),<span class="built_in">scanf</span>() with %s</span><br><span class="line"><span class="built_in">strcpy</span>()</span><br><span class="line"><span class="built_in">strcat</span>()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>attack strategies</p>
<ul>
<li>Brute force to overcome ASLR</li>
<li>ROP to overcome non-executeable stack</li>
<li>However, canary is quite hard to overcome</li>
</ul>
</li>
<li><p>When you do ROP, focus on the byte sequence and don’t be limited by instructions</p>
<p>For example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl $0xc78948d4,(%rdi)		c7 07 d4 48 89 c7</span><br><span class="line">ret							c3</span><br><span class="line"></span><br><span class="line">movq %rax,$rdi	48 89 c7</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://rubbish-and-world.github.io/2021/08/09/CSAPP/Ch3PartIV/" data-id="cl669tx4k005nf6yq9njo3nm5" data-title="Ch3PartIV" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/08/17/CSAPP/bomblab/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          bomblab
        
      </div>
    </a>
  
  
    <a href="/2021/08/05/CSAPP/Ch3PartIII/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Ch3PartIII</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cryptography/">Cryptography</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electronics/">Electronics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLL/">LLL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/NTU/">NTU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/Stanford-CS229/">Stanford CS229</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Math/Discrete-Mathematics/">Discrete Mathematics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/Linear-Algebra/">Linear Algebra</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Missing-Semester/">Missing Semester</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Networking/">Networking</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Networking/Stanford-CS144/">Stanford CS144</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/OS/30DayOS/">30DayOS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/">Python OG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csapp/">csapp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/feelings/">feelings</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/noval/">noval</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/game/" style="font-size: 10px;">game</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/23/Math/LinearAlgebra/VectorSpace/">VectorSpace</a>
          </li>
        
          <li>
            <a href="/2022/07/23/Math/LinearAlgebra/Transpose/">Transpose</a>
          </li>
        
          <li>
            <a href="/2022/07/08/LoaderLinkerLib/StaticLink/">StaticLink</a>
          </li>
        
          <li>
            <a href="/2022/07/08/LoaderLinkerLib/Introduction/">Introduction</a>
          </li>
        
          <li>
            <a href="/2022/07/03/miscellaneous/MoreAboutC/">MoreAboutC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 rubbish<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>