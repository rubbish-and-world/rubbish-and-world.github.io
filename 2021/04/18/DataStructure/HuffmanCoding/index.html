<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HuffmanCoding | rubbishbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="basic idea behind Huffman coding: to use fewer bits for characters that occur more frequently.">
<meta property="og:type" content="article">
<meta property="og:title" content="HuffmanCoding">
<meta property="og:url" content="http://rubbish-and-world.github.io/2021/04/18/DataStructure/HuffmanCoding/index.html">
<meta property="og:site_name" content="rubbishbin">
<meta property="og:description" content="basic idea behind Huffman coding: to use fewer bits for characters that occur more frequently.">
<meta property="og:locale">
<meta property="article:published_time" content="2021-04-18T05:44:49.000Z">
<meta property="article:modified_time" content="2021-04-18T06:41:32.302Z">
<meta property="article:author" content="rubbish">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="rubbishbin" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rubbishbin</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://rubbish-and-world.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-DataStructure/HuffmanCoding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/DataStructure/HuffmanCoding/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T05:44:49.000Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Data-Structure/">Data Structure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      HuffmanCoding
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>basic idea behind Huffman coding: to use <strong>fewer bits for characters that occur more frequently</strong></em>.</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>The output from Huffman’s algorithm can be viewed as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Variable-length_code">variable-length code</a> table for encoding a source symbol (such as a character in a file). The algorithm derives this table from the estimated probability or frequency of occurrence (<em>weight</em>) for each possible value of the source symbol.</p>
</blockquote>
<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><blockquote>
<p>Huffman coding uses a specific method for choosing the representation for each symbol, resulting in a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Prefix_code">prefix code</a> (sometimes called “prefix-free codes”, that is, <strong>the bit string representing some particular symbol is never a prefix of the bit string representing any other symbol</strong>)</p>
</blockquote>
<h3 id="Problem-definition"><a href="#Problem-definition" class="headerlink" title="Problem definition"></a>Problem definition</h3><h4 id="Given"><a href="#Given" class="headerlink" title="Given"></a><strong>Given</strong></h4><p>A set of symbols and their weights (usually <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Proportionality_(mathematics)">proportional</a> to probabilities).</p>
<h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a><strong>Find</strong></h4><p>A <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Prefix_code">prefix-free binary code</a> (a set of codewords) with minimum <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Expected_value">expected</a> codeword length (equivalently, a tree with minimum <a target="_blank" rel="noopener" href="https://en.wikipedia.org/w/index.php?title=Weighted_path_length_from_the_root&action=edit&redlink=1">weighted path length from the root</a>).</p>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Two-type-of-nodes"><a href="#Two-type-of-nodes" class="headerlink" title="Two type of nodes"></a>Two type of nodes</h4><ul>
<li><p>Leaf nodes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LeafNode</span>&#123;</span></span><br><span class="line">    Type symbol ; <span class="comment">// the type of the thing you want to compress</span></span><br><span class="line">    <span class="keyword">double</span> weight ; <span class="comment">// usually is the frequency of apparence</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LeafNode</span> * <span class="title">parent</span> ;</span></span><br><span class="line">&#125;LeafNode ;</span><br></pre></td></tr></table></figure></li>
<li><p>Internal nodes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">InternalNode</span>&#123;</span></span><br><span class="line">    LeafNode * Lchild ; </span><br><span class="line">    LeafNode * Rchild ;</span><br><span class="line">    <span class="keyword">double</span> weight ; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">InternalNode</span> * <span class="title">parent</span> ;</span> <span class="comment">//this is optional</span></span><br><span class="line">&#125;InternalNode;</span><br></pre></td></tr></table></figure></li>
<li><p>The process begins with the leaf nodes containing the probabilities of the symbol they represent.</p>
</li>
<li><p>Then, the process <strong>takes the two nodes with smallest probability, and creates a new internal node having these two nodes as children</strong>. The weight of the new node is set to the sum of the weight of the children.</p>
</li>
<li><p>We then apply the process again, on the new internal node and on the remaining nodes, we repeat this process until only one node remains, which is the root of the Huffman tree.</p>
</li>
<li><p>we’re <strong>building a single tree from a group (or forest) of trees</strong>. Initially, all the trees have a single node containing a character and the character’s weight.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://demo.tinyray.com/huffman">A visualization of Huffman coding</a></p>
</li>
</ul>
<h3 id="Decompression"><a href="#Decompression" class="headerlink" title="Decompression"></a>Decompression</h3><p>Generally speaking, the process of decompression is simply a matter of translating the stream of prefix codes to individual byte values, usually by traversing the Huffman tree node by node as each bit is read from the input stream (reaching a leaf node necessarily terminates the search for that particular byte value).</p>
<h2 id="C-implementation"><a href="#C-implementation" class="headerlink" title="C implementation"></a>C implementation</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Type unsigned char</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heaplength 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> char_kind 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left(i) ((i)*2+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right(i) ((i)*2+2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> parent(i) (((i)-1)/2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smaller(a,b) ((h-&gt;start[a].w) <span class="meta-string">&lt;= (h-&gt;start[b].w) ? (a):(b) )</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallest(a,b,c) smaller(smaller(a,b) ,(c))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isLeaf(root) ((root)-&gt;left == NULL &amp;&amp; (root)-&gt;right==NULL)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  alphabet [char_kind] ;</span><br><span class="line"><span class="keyword">char</span> huffs [N][N] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_frequency</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hfmTNode</span>&#123;</span></span><br><span class="line">    Type element ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> w ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hfmTNode</span> * <span class="title">left</span> ;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hfmTNode</span> * <span class="title">right</span> ;</span></span><br><span class="line">&#125;Node ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node * a , Node * b )</span></span>&#123;</span><br><span class="line">    Node  temp  = *a ;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newnode</span><span class="params">(Type data , <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> weight )</span></span>&#123;</span><br><span class="line">    Node* res = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    res-&gt;element = data;</span><br><span class="line">    res-&gt;w = weight;</span><br><span class="line">    res-&gt;left = res-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> maxlength;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    Node* start;</span><br><span class="line">&#125;Heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Heap * h)</span></span>&#123;</span><br><span class="line">    h-&gt;maxlength = heaplength ;</span><br><span class="line">    h-&gt;start = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node) * h-&gt;maxlength);</span><br><span class="line">    h-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Heap * h)</span></span>&#123; <span class="built_in">free</span>(h-&gt;start); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percolateup</span><span class="params">(Heap * h , <span class="keyword">size_t</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= h-&gt;size || position &lt; <span class="number">0</span> ) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(parent(position)&gt;=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(h-&gt;start[parent(position)].w &lt;= h-&gt;start[position].w) <span class="keyword">break</span>;</span><br><span class="line">        swap(&amp;h-&gt;start[parent(position)] , &amp;h-&gt;start[position]);</span><br><span class="line">        position = parent(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percolatedown</span><span class="params">(Heap * h , <span class="keyword">size_t</span> position)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= h-&gt;size || position &lt; <span class="number">0</span> ) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(left(position) &lt; h-&gt;size )&#123;</span><br><span class="line">        <span class="keyword">size_t</span> min ;</span><br><span class="line">        <span class="keyword">if</span> (right(position) &lt; h-&gt;size)&#123;</span><br><span class="line">        min = smallest(position , left(position) , right(position));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; min = smaller(position , left(position));</span><br><span class="line">        &#125; <span class="keyword">if</span> (min == position) <span class="keyword">break</span>;</span><br><span class="line">        swap(&amp;h-&gt;start[position] , &amp;h-&gt;start[min]);</span><br><span class="line">        position = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_append</span><span class="params">(Heap* h  , Node * node)</span></span>&#123;</span><br><span class="line">    h-&gt;start[h-&gt;size++] = *node;</span><br><span class="line">    percolateup(h , h-&gt;size - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">heap_pop</span><span class="params">(Heap * h )</span></span>&#123;</span><br><span class="line">    Node * res = newnode(h-&gt;start[<span class="number">0</span>].element , h-&gt;start[<span class="number">0</span>].w);</span><br><span class="line">    res-&gt;left = h-&gt;start[<span class="number">0</span>].left;</span><br><span class="line">    res-&gt;right = h-&gt;start[<span class="number">0</span>].right;</span><br><span class="line">    swap(&amp;h-&gt;start[<span class="number">0</span>] , &amp;h-&gt;start[--(h-&gt;size)]);</span><br><span class="line">    percolatedown(h , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHuffmanTree</span><span class="params">(Heap * h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(h-&gt;size != <span class="number">1</span>)&#123;</span><br><span class="line">        Node * l = heap_pop(h);</span><br><span class="line">        Node * r = heap_pop(h);</span><br><span class="line">        Node * <span class="keyword">new</span> = newnode(<span class="string">&#x27;#&#x27;</span> , l-&gt;w + r-&gt;w );</span><br><span class="line">        <span class="keyword">new</span>-&gt;left = l;</span><br><span class="line">        <span class="keyword">new</span>-&gt;right = r;</span><br><span class="line">        heap_append(h , <span class="keyword">new</span>);</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">//I could have been more elegant here, I should use pointer-to-pointer more instead of arguments copying</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write2huff</span><span class="params">(<span class="keyword">char</span> * bf , <span class="keyword">size_t</span> length , <span class="keyword">unsigned</span> <span class="keyword">char</span> destination)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;  i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (bf[i]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">strcat</span>(huffs[destination], <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bf[i]==<span class="string">&#x27;0&#x27;</span>) <span class="built_in">strcat</span>(huffs[destination], <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;[error!]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node * root ,  <span class="keyword">char</span> * buffer , <span class="keyword">size_t</span> length )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(root))&#123;</span><br><span class="line">        <span class="comment">//save huffman code into array</span></span><br><span class="line">        write2huff(buffer, length, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)root-&gt;element);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[length++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    encode(root-&gt;left , buffer , length );</span><br><span class="line">    length--; <span class="comment">//back one step, in each node, you can only move to one direction per time</span></span><br><span class="line">    buffer[length++] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    encode(root-&gt;right , buffer , length );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Heap *  <span class="title">HuffmanEncode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename)</span></span>&#123;</span><br><span class="line">    count_frequency(filename);</span><br><span class="line">    <span class="comment">//creat Huffman heap</span></span><br><span class="line">    Heap * min_heap  = (Heap*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Heap));</span><br><span class="line">    initialize(min_heap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span> ; i &lt; char_kind ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (alphabet[i])&#123;</span><br><span class="line">            Node * <span class="keyword">new</span> = newnode((<span class="keyword">unsigned</span> <span class="keyword">char</span>)i , alphabet[i]);</span><br><span class="line">            heap_append(min_heap , <span class="keyword">new</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">new</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    createHuffmanTree(min_heap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Huffman Encode</span></span><br><span class="line">    <span class="keyword">char</span> buffer [N];<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N ; i++) buffer[i] = <span class="number">0</span>; <span class="comment">//clear buffer</span></span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    encode(&amp;min_heap-&gt;start[<span class="number">0</span>] , buffer , length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return Huffman heap</span></span><br><span class="line">    <span class="keyword">return</span> min_heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root , <span class="keyword">char</span> * signals , <span class="keyword">size_t</span> * length ,  FILE * binaryfile)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(root))&#123;</span><br><span class="line">        fputc(root-&gt;element, binaryfile);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">char</span> choice = signals[(*length)++];</span><br><span class="line">    <span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span> :&#123;</span><br><span class="line">            decode(root-&gt;left , signals , length , binaryfile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:&#123;</span><br><span class="line">            decode(root-&gt;right , signals , length , binaryfile);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;invalid code\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_frequency</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>&#123;</span><br><span class="line">    FILE * file = fopen(name , <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file not found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c = fgetc(file);</span><br><span class="line">    <span class="keyword">while</span>(c!=EOF)&#123;</span><br><span class="line">        alphabet[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c]++;</span><br><span class="line">        c = fgetc(file);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------my bytes loop queue-----------------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ByteQ</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * head ;</span><br><span class="line">    <span class="keyword">int</span> maxsize ;</span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> front ;</span><br><span class="line">    <span class="keyword">int</span> rear ;</span><br><span class="line">&#125;ByteQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">(ByteQ* bq , <span class="keyword">int</span> msize)</span></span>&#123;</span><br><span class="line">    bq-&gt;head = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(msize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    bq-&gt;maxsize = msize;</span><br><span class="line">    bq-&gt;size = <span class="number">0</span>;</span><br><span class="line">    bq-&gt;front = bq-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user should check overflow himself</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equeue</span><span class="params">(<span class="keyword">char</span> * bitstring , ByteQ * bq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> space = <span class="built_in">strlen</span>(bitstring);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; space ; i++)&#123;</span><br><span class="line">        bq-&gt;head[((bq-&gt;rear)++)%bq-&gt;maxsize]=bitstring[i];</span><br><span class="line">        bq-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//user should check empty himself</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dqueue</span><span class="params">(ByteQ * bq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = bq-&gt;head[(bq-&gt;front)++ % bq-&gt;maxsize];</span><br><span class="line">        bq-&gt;size--;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error happens when dqueue\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_string</span><span class="params">(<span class="keyword">const</span> ByteQ * bq , <span class="keyword">int</span> lengthOfstring , <span class="keyword">char</span> * res )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; lengthOfstring ; i++)&#123;</span><br><span class="line">        res[i] = bq-&gt;head[(bq-&gt;front + i)%bq-&gt;maxsize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_string</span><span class="params">(ByteQ * bq , <span class="keyword">size_t</span> lengthOfstring)</span></span>&#123;</span><br><span class="line">    bq-&gt;front = (bq-&gt;front + lengthOfstring) % bq-&gt;maxsize;</span><br><span class="line">    bq-&gt;size -= lengthOfstring;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------my bytes loop queue-----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress2bin</span><span class="params">(<span class="keyword">char</span> * file2bcompressed , <span class="keyword">char</span> * binaryfile)</span></span>&#123;</span><br><span class="line">    FILE * file = fopen(file2bcompressed, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    FILE * bin = fopen(binaryfile, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    ByteQ * bq = (ByteQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ByteQ));</span><br><span class="line">    initial(bq, N);</span><br><span class="line">    <span class="keyword">char</span> c = fgetc(file);</span><br><span class="line">    <span class="keyword">while</span> (c!=EOF) &#123;</span><br><span class="line">        equeue(huffs[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c], bq);</span><br><span class="line">        <span class="keyword">while</span>(bq-&gt;size &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> byte = dqueue(bq);</span><br><span class="line">            fputc((<span class="keyword">unsigned</span> <span class="keyword">char</span>)byte, bin);</span><br><span class="line">        &#125;</span><br><span class="line">        c = fgetc(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (bq-&gt;size % <span class="number">8</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        equeue(<span class="string">&quot;0&quot;</span>, bq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (bq-&gt;size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fputc((<span class="keyword">unsigned</span> <span class="keyword">char</span>)dqueue(bq), bin);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(bin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress2txt</span><span class="params">( <span class="keyword">char</span> * originfile , <span class="keyword">char</span> * text_file_name )</span></span>&#123;</span><br><span class="line">    FILE * tobcompressed = fopen(originfile , <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    FILE * text = fopen(text_file_name , <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> c = fgetc(tobcompressed);</span><br><span class="line">    <span class="keyword">while</span> (c != EOF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(text, <span class="string">&quot;%s&quot;</span> , huffs[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c]);</span><br><span class="line">        c = fgetc(tobcompressed);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(tobcompressed);</span><br><span class="line">    fclose(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">char2str</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> number  , <span class="keyword">char</span> * bitstring)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        bitstring[i] = (<span class="keyword">char</span>)( (number &amp;  <span class="number">0b00000001</span>) + <span class="number">48</span>);</span><br><span class="line">        number &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decompress</span><span class="params">(<span class="keyword">char</span> * file2bdecomp , <span class="keyword">char</span> * output , Heap * huffheap)</span></span>&#123;</span><br><span class="line">    FILE * file = fopen(file2bdecomp, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE * out = fopen(output, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span>  length = <span class="number">0</span>;</span><br><span class="line">    ByteQ * bq = (ByteQ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ByteQ));</span><br><span class="line">    initial(bq, N);</span><br><span class="line">    <span class="keyword">char</span> eight [<span class="number">9</span>];eight[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> c = fgetc(file);</span><br><span class="line">    <span class="keyword">char</span> signals [<span class="number">24</span>] ;</span><br><span class="line">    <span class="keyword">while</span> (!feof(file)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            char2str((<span class="keyword">unsigned</span> <span class="keyword">char</span>)(c) , eight);</span><br><span class="line">            <span class="keyword">if</span> (bq-&gt;size &lt;= bq-&gt;maxsize - <span class="number">8</span>)&#123;</span><br><span class="line">                equeue(eight, bq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            c = fgetc(file);</span><br><span class="line">            <span class="keyword">if</span> (feof(file)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        get_string(bq , <span class="number">24</span>, signals);</span><br><span class="line">        decode(&amp;huffheap-&gt;start[<span class="number">0</span>], signals, &amp;length , out);</span><br><span class="line">        pop_string(bq, length);</span><br><span class="line">            length=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// because the shortest huffman code has lenght of 3</span></span><br><span class="line">    <span class="keyword">while</span> (bq-&gt;size &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        get_string(bq , <span class="number">24</span>, signals);</span><br><span class="line">        decode(&amp;huffheap-&gt;start[<span class="number">0</span>], signals, &amp;length , out);</span><br><span class="line">        pop_string(bq, length);</span><br><span class="line">            length=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeSymbol</span><span class="params">(<span class="keyword">char</span> * symbolfilename)</span></span>&#123;</span><br><span class="line">    FILE * symbol = fopen(symbolfilename , <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (huffs[i] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span> )i == <span class="number">0xa</span>) <span class="built_in">fprintf</span>(symbol ,  <span class="string">&quot;%u:\\n:%s\n&quot;</span> , (<span class="keyword">unsigned</span> <span class="keyword">char</span> )i , huffs[i] );</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">fprintf</span>( symbol , <span class="string">&quot;%u:%c:%s\n&quot;</span> , (<span class="keyword">unsigned</span> <span class="keyword">char</span> )i, (<span class="keyword">unsigned</span> <span class="keyword">char</span> )i , huffs[i] );</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(symbol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> * argv [])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * f = <span class="string">&quot;pride.txt&quot;</span>;             <span class="comment">//file to be compressed</span></span><br><span class="line">    <span class="keyword">char</span> * textname=<span class="string">&quot;ttttext.txt&quot;</span>;      <span class="comment">//bitstring file</span></span><br><span class="line">    <span class="keyword">char</span> * symbolname = <span class="string">&quot;ssssymbols.txt&quot;</span>;<span class="comment">//huffman code for all symbols</span></span><br><span class="line">    <span class="keyword">char</span> * binname = <span class="string">&quot;bbbbinary.dat&quot;</span>;   <span class="comment">//compressed binary file</span></span><br><span class="line">    <span class="keyword">char</span> * output = <span class="string">&quot;ooooutput.txt&quot;</span>;    <span class="comment">//decompressed text file</span></span><br><span class="line"></span><br><span class="line">    Heap * huffheap = HuffmanEncode(f);</span><br><span class="line">    writeSymbol(symbolname);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;symbols created.\n&quot;</span>);</span><br><span class="line">    compress2bin(f, binname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;successfully compress to binary !!!\n&quot;</span>);</span><br><span class="line">    compress2txt(f, textname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;successfully compress to bitstring !!!\n&quot;</span>);</span><br><span class="line">    decompress(binname, output, huffheap);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;successfully decompress binary file !!!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    destroy(huffheap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>In case of there are some non-ascii characters in the file to be compressed, In order to do a lossless decompression, I arbitrarily read the file byte by byte, though this may spoil the frequency of appearance.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">a</span><br><span class="line">Í</span><br><span class="line">$ hexdump -C &lt; test.txt &gt; testdump  &amp;&amp; cat testdump</span><br><span class="line">00000000  61 0a c3 8d 0a                              |a....|</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Í&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xc3\x8d&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE * file = fopen(<span class="string">&quot;test.txt&quot;</span> , <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">	FILE * result = fopen(<span class="string">&quot;result.txt&quot;</span> , <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> c = fgetc(file);</span><br><span class="line">	<span class="keyword">while</span>(c != EOF)&#123;</span><br><span class="line">		fputc(c , result);</span><br><span class="line">		c = fgetc(file);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat result.txt</span><br><span class="line">a</span><br><span class="line">Í</span><br><span class="line">$ diff test.txt result.txt</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li>
<li><p><code>char</code> is a signed byte, this may lead to some troubles, so I convert it to <code>unsigned char</code> to represent <code>0-255</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE * file = fopen(<span class="string">&quot;test.txt&quot;</span> , <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">	FILE * result = fopen(<span class="string">&quot;result.txt&quot;</span> , <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span> c = fgetc(file);</span><br><span class="line">	<span class="keyword">while</span>(c != EOF)&#123;</span><br><span class="line">		fputc(c , result);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;signed : %d\tunsigned :%u\n&quot;</span> , c ,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)c);</span><br><span class="line">		c = fgetc(file);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc frw.c -o frw &amp;&amp; ./frw</span><br><span class="line">signed : 97	unsigned :97</span><br><span class="line">signed : 10	unsigned :10</span><br><span class="line">signed : -61	unsigned :195</span><br><span class="line">signed : -115	unsigned :141</span><br><span class="line">signed : 10	unsigned :10</span><br></pre></td></tr></table></figure></li>
<li><p>use bitwise operation to convert between <code>byte</code> and <code>bitstring</code></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">char2str</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> number  , <span class="keyword">char</span> * bitstring)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        bitstring[i] = (<span class="keyword">char</span>)( (number &amp;  <span class="number">0b00000001</span>) + <span class="number">48</span>);</span><br><span class="line">        number &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">dqueue</span><span class="params">(ByteQ * bq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = bq-&gt;head[(bq-&gt;front)++ % bq-&gt;maxsize];</span><br><span class="line">        bq-&gt;size--;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error happens when dqueue\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>In case of I need to decompress a very large file, I implement a customized <code>queue</code> to mimic a <code>stream parser</code></p>
</li>
<li><p>The program seems to work nicely on my MacOS, but on Windows it will encounter a wired memory access error, during malloc memory, a pointer will get a very small address, like <code>0x5d</code>, which will lead to a <code>permission denied</code> later, I don’t know why.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://rubbish-and-world.github.io/2021/04/18/DataStructure/HuffmanCoding/" data-id="cknmsxu760000wbyqd0tqhq5m" data-title="HuffmanCoding" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/18/miscellaneous/proxy-stuff/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          proxy stuff
        
      </div>
    </a>
  
  
    <a href="/2021/04/16/Cryptography/Hash-MAC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Hash&amp;MAC</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cryptography/">Cryptography</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/NTU/">NTU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/Stanford-CS229/">Stanford CS229</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Math/Discrete-Mathematics/">Discrete Mathematics</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/">Python OG</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/1-Whetting-your-appetite/">1.Whetting your appetite</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/10-Brief-Tour-of-the-Standard-Library/">10.Brief Tour of the Standard Library</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/11-Brief-Tour-of-the-Standard-Library-%E2%80%94-Part-II/">11.Brief Tour of the Standard Library — Part II</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/12-Virtual-Environments-and-Packages/">12.Virtual Environments and Packages</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/13-What-Now-The-Rest-of-The-Tutorial/">13.What Now & The Rest of The Tutorial</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/2-Using-the-Python-Interpreter/">2.Using the Python Interpreter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/3-An-Informal-Introduction-to-Python/">3.An Informal Introduction to Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/4-More-Control-Flow-Tools/">4.More Control Flow Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/5-Data-Structures/">5.Data Structures</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/6-Modules/">6.Modules</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/7-Input-and-Output/">7.Input and Output</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/8-Errors-and-Exceptions/">8.Errors and Exceptions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/9-Classes/">9.Classes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/introduction/">introduction</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/game/" style="font-size: 10px;">game</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/06/feelings/Answer/">Answer</a>
          </li>
        
          <li>
            <a href="/2021/04/22/DataStructure/PriorityQueue/">PriorityQueue</a>
          </li>
        
          <li>
            <a href="/2021/04/18/miscellaneous/proxy-stuff/">proxy stuff</a>
          </li>
        
          <li>
            <a href="/2021/04/18/DataStructure/HuffmanCoding/">HuffmanCoding</a>
          </li>
        
          <li>
            <a href="/2021/04/16/Cryptography/Hash-MAC/">Hash&amp;MAC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 rubbish<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>