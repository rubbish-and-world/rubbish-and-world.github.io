<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Ch9 | rubbishbin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="MathJax.Hub.Config({ tex2jax: {inlineMath: [[&#39;$&#39;, &#39;$&#39;]]}, messageStyle: &quot;none&quot; });  Virtual Memory">
<meta property="og:type" content="article">
<meta property="og:title" content="Ch9">
<meta property="og:url" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/index.html">
<meta property="og:site_name" content="rubbishbin">
<meta property="og:description" content="MathJax.Hub.Config({ tex2jax: {inlineMath: [[&#39;$&#39;, &#39;$&#39;]]}, messageStyle: &quot;none&quot; });  Virtual Memory">
<meta property="og:locale">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/PA.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/VA.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/Vmsys.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/pagetable.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/pagefault.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/alloca.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/MM.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/mmcontrol.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/symbols.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/addresstrans.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/operations.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/cachePA.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/tlb.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/tlboperation.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/multPT.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/addrtrans.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/pagetable.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/level4addr.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/memspace.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/taskstruct.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/pagefaulthandler.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/sharedobj.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/privateobj.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/override.png">
<meta property="og:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/mmp.png">
<meta property="article:published_time" content="2021-10-05T04:10:53.000Z">
<meta property="article:modified_time" content="2021-10-06T12:32:55.185Z">
<meta property="article:author" content="rubbish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/PA.png">
  
    <link rel="alternate" href="/atom.xml" title="rubbishbin" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">rubbishbin</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://rubbish-and-world.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-CSAPP/Ch9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/05/CSAPP/Ch9/" class="article-date">
  <time class="dt-published" datetime="2021-10-05T04:10:53.000Z" itemprop="datePublished">2021-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/csapp/">csapp</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Ch9
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>

<h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><a id="more"></a>

<p><em>virtual memory provides three important capabilities</em></p>
<ul>
<li>Uses main memory efficiently by treating it as a cache for an address space stored on disk, keeping only the active areas in main memory and transferring data back and forth between disk and memory as needed</li>
<li>It simplifies memory management by providing each process with a uniform address space.</li>
<li>It protects the address space of each process from corruption by other processes.(Each process has its own page table)</li>
</ul>
<p>A major reason for its success is that it works <strong>silently and automatically, without any intervention from the application programmer</strong></p>
<h2 id="9-1-Physical-and-Virtual-Addressing"><a href="#9-1-Physical-and-Virtual-Addressing" class="headerlink" title="9.1 Physical and Virtual Addressing"></a>9.1 Physical and Virtual Addressing</h2><p><em>Physical : The main memory of a computer system is organized as an array of <code>M </code> contiguous byte-size cells. Each byte has a unique physical address . The first byte has an address of 0</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/PA.png" alt="Physical Addressing"></p>
<p><em>Virtual : the CPU accesses main memory by generating a virtual address, which is converted to the appropriate physical address before being sent to main memory. The task of converting a virtual address to a physical one is known as address translation</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/VA.png" alt="Vitual Addressing"></p>
<h2 id="9-2-Address-Spaces"><a href="#9-2-Address-Spaces" class="headerlink" title="9.2 Address Spaces"></a>9.2 Address Spaces</h2><p><em>An address space is an ordered set of nonnegative integer addresses {0, 1, 2,…}</em></p>
<p>If the integers in the address space are consecutive, then we say that it is a <strong>linear address space.</strong></p>
<h4 id="Virtual-Memory-Space"><a href="#Virtual-Memory-Space" class="headerlink" title="Virtual Memory Space"></a>Virtual Memory Space</h4><p>$$<br>{ 0,1,2,…,N-1} , N=2^n<br>$$</p>
<ul>
<li>n is the number of bits can be used to represent addresses(width of address bus)</li>
<li>In modern system, n is either 32 or 64</li>
</ul>
<h4 id="Phiscal-Memory-Space"><a href="#Phiscal-Memory-Space" class="headerlink" title="Phiscal Memory Space"></a>Phiscal Memory Space</h4><p>$$<br>{0,1,2,…,M-1}<br>$$</p>
<ul>
<li>M doesn’t need to be power of 2</li>
<li>M is the number of bytes we acutally have in memory</li>
</ul>
<h4 id="Basic-Concept-of-Virtual-Memory"><a href="#Basic-Concept-of-Virtual-Memory" class="headerlink" title="Basic Concept of Virtual Memory"></a>Basic Concept of Virtual Memory</h4><p><strong><em>Allow each data object to have multiple independent addresses, each chosen from a different address space.</em></strong></p>
<p>(Each byte of main memory has a virtual address chosen from the virtual address space, and a physical address chosen from the physical address space.)</p>
<h2 id="9-3-VM-as-a-Tool-for-Caching"><a href="#9-3-VM-as-a-Tool-for-Caching" class="headerlink" title="9.3 VM as a Tool for Caching"></a>9.3 VM as a Tool for Caching</h2><p><em>Conceptually, a virtual memory is organized as an array of N contiguous byte-size cells stored on <strong>disk</strong></em></p>
<ul>
<li>The contents of the array on disk are cached in main memory</li>
<li>The system partitioning the virtual memory into fixed-size blocks called <strong>virtual pages</strong>, P bytes per page</li>
<li>Physical memory is partitioned into <strong>physical pages</strong> , also P bytes in size</li>
</ul>
<p>At any point in time, <strong>the set of virtual pages</strong> is partitioned into three <strong>disjoint subsets</strong>:</p>
<ul>
<li>Unallocated. <ul>
<li>Pages that have not yet been allocated (or created) by the VM system. </li>
<li>Unallocated blocks do not have any data associated with them, and thus do not occupy any space on disk.</li>
</ul>
</li>
<li>Cached<ul>
<li>Allocated pages that are currently cached in physical memory</li>
</ul>
</li>
<li>Uncached. <ul>
<li>Allocated pages that are not cached in physical memory</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/05/CSAPP/Ch9/Vmsys.png" alt="Virtual Memory System"></p>
<h3 id="9-3-1-DRAM-Cache-Organization"><a href="#9-3-1-DRAM-Cache-Organization" class="headerlink" title="9.3.1 DRAM Cache Organization"></a>9.3.1 DRAM Cache Organization</h3><p><em>the organization of the DRAM cache is <strong>driven entirely by the enormous cost of misses</strong></em></p>
<ul>
<li>Because of the large miss penalty and the expense of accessing the first byte, <strong>virtual pages tend to be large</strong>—typically 4 KB to 2 MB</li>
<li>Due to the large miss penalty, DRAM caches are <strong>fully associative</strong><ul>
<li>Only one set, any virtual page can be placed in any physical page</li>
</ul>
</li>
<li>Operating systems use much more <strong>sophisticated replacement algorithms</strong> for DRAM caches than the hardware does for SRAM caches.</li>
<li>Because of the large access time of disk, DRAM caches always use <strong>write-back</strong> instead of write-through.</li>
</ul>
<h3 id="9-3-2-Page-Tables"><a href="#9-3-2-Page-Tables" class="headerlink" title="9.3.2 Page Tables"></a>9.3.2 Page Tables</h3><p>The address translation hardware reads the page table each time it converts a virtual address to a physical address. </p>
<p>The operating system is responsible for maintaining the contents of the page table and transferring pages back and forth between disk and DRAM.</p>
<p><img src="/2021/10/05/CSAPP/Ch9/pagetable.png" alt="page table"></p>
<ul>
<li>A page table is an array of page table entries (PTEs)</li>
<li>Each page in the virtual address space has a PTE at a fixed offset in the page table.</li>
<li>If the valid bit is set, the address field indicates the start of the corresponding physical page in DRAM where the virtual page is cached</li>
</ul>
<h4 id="Practice-Problem-9-2"><a href="#Practice-Problem-9-2" class="headerlink" title="Practice Problem 9.2"></a>Practice Problem 9.2</h4><blockquote>
<p>Determine the number of page table entries (PTEs) that are needed for the following combinations of virtual address size (n) and page size (P):</p>
<table>
<thead>
<tr>
<th>n</th>
<th>$P=2^p$</th>
<th>Number of PTEs</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>1K</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>16K</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>2M</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>1G</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="My-solution-white-check-mark"><a href="#My-solution-white-check-mark" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><p>$$<br>2^n / P = 2^{n-p}<br>$$</p>
<table>
<thead>
<tr>
<th>n</th>
<th>$P=2^p$</th>
<th>Number of PTEs</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>1K</td>
<td>4</td>
</tr>
<tr>
<td>16</td>
<td>16K</td>
<td>4</td>
</tr>
<tr>
<td>24</td>
<td>2M</td>
<td>8</td>
</tr>
<tr>
<td>36</td>
<td>1G</td>
<td>64</td>
</tr>
</tbody></table>
<h3 id="9-3-3-Page-Hits"><a href="#9-3-3-Page-Hits" class="headerlink" title="9.3.3 Page Hits"></a>9.3.3 Page Hits</h3><h3 id="9-3-4-Page-Faults"><a href="#9-3-4-Page-Faults" class="headerlink" title="9.3.4 Page Faults"></a>9.3.4 Page Faults</h3><p><em>A DRAM cache miss is known as a page fault.</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/pagefault.png" alt="page fault"></p>
<h3 id="9-3-5-Allocating-Pages"><a href="#9-3-5-Allocating-Pages" class="headerlink" title="9.3.5 Allocating Pages"></a>9.3.5 Allocating Pages</h3><p><em>Figure 9.8 shows the effect on our example page table when the operating system allocates a new page of virtual memory—for example, as a result of calling malloc.</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/alloca.png" alt="allocate new page"></p>
<h3 id="9-3-6-Locality-to-the-Rescue-Again"><a href="#9-3-6-Locality-to-the-Rescue-Again" class="headerlink" title="9.3.6 Locality to the Rescue Again"></a>9.3.6 Locality to the Rescue Again</h3><p><em>In practice, virtual memory works well, mainly because of locality.</em></p>
<blockquote>
<p>Counting page faults </p>
<p>You can monitor the number of page faults (and lots of other information) with the Linux <code>getrusage</code> function</p>
</blockquote>
<h2 id="9-4-VM-as-a-Tool-for-Memory-Management"><a href="#9-4-VM-as-a-Tool-for-Memory-Management" class="headerlink" title="9.4 VM as a Tool for Memory Management"></a>9.4 VM as a Tool for Memory Management</h2><p><em>In fact, operating systems provide a separate page table, and thus a separate virtual address space, for each process.</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/MM.png" alt="Memory Management"></p>
<p> In particular, VM <strong>simplifies linking and loading, the sharing of code and data, and allocating memory to application</strong></p>
<h4 id="Simplifying-linking"><a href="#Simplifying-linking" class="headerlink" title="Simplifying linking"></a>Simplifying linking</h4><ul>
<li>A separate address space allows each process to use the same basic format for its memory image, regardless of where the code and data actually reside in physical memory</li>
</ul>
<h4 id="Simplifying-loading"><a href="#Simplifying-loading" class="headerlink" title="Simplifying loading."></a>Simplifying loading.</h4><ul>
<li>To load the .text and .data sections of an object file into a newly created process, the Linux loader <strong>allocates virtual pages for the code and data segments, marks them as invalid</strong> (i.e., not cached), and <strong>points their page table entries to the appropriate locations in the object file.</strong></li>
<li><strong>the loader never actually copies</strong> any data from disk into memory</li>
<li> The data are paged in automatically and on demand by the virtual memory system the first time each page is referenced(Copying is done by the OS)</li>
</ul>
<h4 id="Simplifying-sharing"><a href="#Simplifying-sharing" class="headerlink" title="Simplifying sharing"></a>Simplifying sharing</h4><ul>
<li>For unique resources like user-stack, program code, the operating system creates page tables that <strong>map the corresponding virtual pages to disjoint physical pages.</strong></li>
<li>For shared resources like shared libraries, the operating system can arrange for multiple processes to share a single copy of this code by <strong>mapping the appropriate virtual pages in different processes to the same physical page</strong></li>
</ul>
<h4 id="Simplifying-memory-allocation"><a href="#Simplifying-memory-allocation" class="headerlink" title="Simplifying memory allocation"></a>Simplifying memory allocation</h4><ul>
<li>Because of the way page tables work, there is no need for the operating system to locate several contiguous pages of physical memory. The pages can be scattered randomly in physical memory.</li>
</ul>
<h2 id="9-5-VM-as-a-Tool-for-Memory-Protection"><a href="#9-5-VM-as-a-Tool-for-Memory-Protection" class="headerlink" title="9.5 VM as a Tool for Memory Protection"></a>9.5 VM as a Tool for Memory Protection</h2><p><em>Providing separate virtual address spaces makes it easy to isolate the private memories of different processes. But the <strong>address translation mechanism can be extended in a natural way to provide even finer access control</strong>.</em></p>
<p>Since the address translation hardware reads a PTE each time the CPU generates an address, it is straightforward to control access to the contents of a virtual page by adding some additional <strong>permission bits</strong> to the PTE. </p>
<p><img src="/2021/10/05/CSAPP/Ch9/mmcontrol.png" alt="Memory Control"></p>
<h2 id="9-6-Address-Translation"><a href="#9-6-Address-Translation" class="headerlink" title="9.6 Address Translation"></a>9.6 Address Translation</h2><p><em>This section is going to explain how hardware work in address translation, but ignoring some details like timing</em></p>
<p><img src="/2021/10/05/CSAPP/Ch9/symbols.png" alt="symbols"></p>
<p>Formally, address translation is <strong><em>a mapping between the elements of an N element virtual address space (VAS) and an M element physical address space (PAS)</em></strong><br>$$<br>MAP:VAS\rightarrow PAS \cup \O<br>$$<br><img src="/2021/10/05/CSAPP/Ch9/addresstrans.png" alt="Address translation"></p>
<ul>
<li>A control register in the CPU, the page table base register (PTBR) points to the current page table.</li>
<li>The n-bit virtual address has two components: <ul>
<li>$p$ bits <strong>virtual page offset</strong> (VPO)</li>
<li>$(n − p)$ bits <strong>virtual page number</strong> (VPN).</li>
</ul>
</li>
<li>The MMU <strong>uses the VPN to select the appropriate PTE</strong>. For example, VPN 0 selects PTE 0, VPN 1 selects PTE 1, and so on</li>
<li>The corresponding physical address is the <strong>concatenation of the physical page number (PPN)from the page table entry and the VPO from the virtual address.</strong></li>
<li>Notice that since the physical and virtual pages are both P bytes, the physical page offset (PPO)is identical to the VPO.</li>
</ul>
<h4 id="Page-hit-and-Page-fault"><a href="#Page-hit-and-Page-fault" class="headerlink" title="Page hit and Page fault"></a>Page hit and Page fault</h4><p><img src="/2021/10/05/CSAPP/Ch9/operations.png" alt="page operation"></p>
<h5 id="Page-hit"><a href="#Page-hit" class="headerlink" title="Page hit"></a>Page hit</h5><ol>
<li>The processor generates a virtual address and sends it to the MMU.</li>
<li>The MMU generates the PTE address and requests it from the cache/ main memory.</li>
<li>The cache/main memory returns the PTE to the MMU.</li>
<li>The MMU constructs the physical address and sends it to the cache/main memory.</li>
<li>The cache/main memory returns the requested data word to the processor.</li>
</ol>
<h5 id="Page-fault"><a href="#Page-fault" class="headerlink" title="Page fault"></a>Page fault</h5><p>The same as steps 1 to 3  in page hit</p>
<ol start="4">
<li>The valid bit in the PTE is zero, so the MMU triggers an exception, which transfers control in the CPU to a page fault exception handler in the operating system kernel.</li>
<li>The fault handler identifies a victim page in physical memory, and if that page has been modified, pages it out to disk.</li>
<li>The fault handler pages in the new page and updates the PTE in memory</li>
<li>The fault handler returns to the original process, causing the faulting instruction to be restarted. The CPU resends the offending virtual address to the MMU. Because the virtual page is now cached in physical memory, there is a hit, and after the MMU performs the steps in Figure 9.13(a), the main memory returns the requested word to the processor.</li>
</ol>
<h4 id="Practice-Problem-9-3"><a href="#Practice-Problem-9-3" class="headerlink" title="Practice Problem 9.3"></a>Practice Problem 9.3</h4><blockquote>
<p>Given a 64-bit virtual address space and a 32-bit physical address, determine the number of bits in the VPN, VPO, PPN, and PPO for the following page sizes P:</p>
<table>
<thead>
<tr>
<th>P</th>
<th>(number of)VPN bits</th>
<th>VPO bits</th>
<th>PPN bits</th>
<th>PPO bits</th>
</tr>
</thead>
<tbody><tr>
<td>1kb</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2kb</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4kb</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16kb</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="My-solution-white-check-mark-1"><a href="#My-solution-white-check-mark-1" class="headerlink" title="My solution : :white_check_mark:"></a>My solution : :white_check_mark:</h4><p>$$<br>2^{64} \div 2^{10} = 2^{54} (\text{pages})<br>$$</p>
<p>$$<br>VPN=54(bits)<br>$$</p>
<table>
<thead>
<tr>
<th>P</th>
<th>(number of)VPN bits</th>
<th>VPO bits</th>
<th>PPN bits</th>
<th>PPO bits</th>
</tr>
</thead>
<tbody><tr>
<td>1kb</td>
<td>54</td>
<td>10</td>
<td>22</td>
<td>10</td>
</tr>
<tr>
<td>2kb</td>
<td>53</td>
<td>11</td>
<td>21</td>
<td>11</td>
</tr>
<tr>
<td>4kb</td>
<td>52</td>
<td>12</td>
<td>20</td>
<td>12</td>
</tr>
<tr>
<td>16kb</td>
<td>50</td>
<td>14</td>
<td>18</td>
<td>14</td>
</tr>
</tbody></table>
<h3 id="9-6-1-Integrating-Caches-and-VM"><a href="#9-6-1-Integrating-Caches-and-VM" class="headerlink" title="9.6.1 Integrating Caches and VM"></a>9.6.1 Integrating Caches and VM</h3><p><em>In any system that uses both virtual memory and SRAM caches, there is the issue of <strong>whether to use virtual or physical addresses to access the SRAM cache.</strong></em></p>
<p>Most systems opt for physical addressing</p>
<ul>
<li> It is straightforward for multiple processes to have blocks in the cache at the same time and to share blocks from the same virtual pages</li>
<li>The cache does not have to deal with protection issues, because access rights are checked as part of the address translation process.</li>
</ul>
<p><img src="/2021/10/05/CSAPP/Ch9/cachePA.png" alt="cache with physical addressing"></p>
<h3 id="9-6-2-Speeding-Up-Address-Translation-with-a-TLB"><a href="#9-6-2-Speeding-Up-Address-Translation-with-a-TLB" class="headerlink" title="9.6.2 Speeding Up Address Translation with a TLB"></a>9.6.2 Speeding Up Address Translation with a TLB</h3><p><em>Many systems try to eliminate even the cost of finding PTE in level-1 cache by including a small cache of PTEs in the MMU called a translation lookaside buffer (TLB).</em></p>
<ul>
<li>A TLB is a small, virtually addressed cache where each line holds a block consisting of a single PTE.</li>
<li>A TLB usually has a high degree of associativity</li>
</ul>
<p><img src="/2021/10/05/CSAPP/Ch9/tlb.png" alt="Translation lookaside buffer"></p>
<h4 id="TLB-Operation"><a href="#TLB-Operation" class="headerlink" title="TLB Operation"></a>TLB Operation</h4><p><img src="/2021/10/05/CSAPP/Ch9/tlboperation.png" alt="TLB operations"></p>
<h3 id="9-6-3-Multi-Level-Page-Tables"><a href="#9-6-3-Multi-Level-Page-Tables" class="headerlink" title="9.6.3 Multi-Level Page Tables"></a>9.6.3 Multi-Level Page Tables</h3><p><em>If we only use a single page table to do the translation, we will have a very large page table resident in memory</em></p>
<p><em>The common approach for compacting the page table is to use a hierarchy of page tables instead</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Just like two star pointer, it is a page table to page table</span></span><br><span class="line"><span class="comment">//PageTable can also be view as a page</span></span><br><span class="line">PageTable* level1 [N];</span><br></pre></td></tr></table></figure>


<p><img src="/2021/10/05/CSAPP/Ch9/multPT.png" alt="multiple level cache"></p>
<p>Why multiple level tables save space ? </p>
<ul>
<li>level 2(or lower levels) are generated dynamically, they only exist when they are needed).</li>
<li><code>sizeof(PageTable*) &lt; sizeof(PageTable)</code></li>
</ul>
<h3 id="9-6-4-Putting-It-Together-End-to-End-Address-Translation"><a href="#9-6-4-Putting-It-Together-End-to-End-Address-Translation" class="headerlink" title="9.6.4 Putting It Together: End-to-End Address Translation"></a>9.6.4 Putting It Together: End-to-End Address Translation</h3><h2 id="9-7-Case-Study-The-Intel-Core-i7-Linux-Memory-System"><a href="#9-7-Case-Study-The-Intel-Core-i7-Linux-Memory-System" class="headerlink" title="9.7 Case Study: The Intel Core i7/Linux Memory System"></a>9.7 Case Study: The Intel Core i7/Linux Memory System</h2><p><img src="/2021/10/05/CSAPP/Ch9/addrtrans.png" alt="address translation on real machine"></p>
<h3 id="9-7-1-Core-i7-Address-Translation"><a href="#9-7-1-Core-i7-Address-Translation" class="headerlink" title="9.7.1 Core i7 Address Translation"></a>9.7.1 Core i7 Address Translation</h3><p><img src="/2021/10/05/CSAPP/Ch9/pagetable.png" alt="page table entry"></p>
<p><img src="/2021/10/05/CSAPP/Ch9/level4addr.png" alt="level 4 page table entry"></p>
<h3 id="9-7-2-Linux-Virtual-Memory-System"><a href="#9-7-2-Linux-Virtual-Memory-System" class="headerlink" title="9.7.2 Linux Virtual Memory System"></a>9.7.2 Linux Virtual Memory System</h3><p><img src="/2021/10/05/CSAPP/Ch9/memspace.png" alt="Virtual Memory Space"></p>
<p>Each process shares the kernel’s code and global data structures.</p>
<h4 id="Linux-Virtual-Memory-Areas"><a href="#Linux-Virtual-Memory-Areas" class="headerlink" title="Linux Virtual Memory Areas"></a>Linux Virtual Memory Areas</h4><p><em>Linux organizes the virtual memory as a collection of <strong>areas</strong> (also called segments).</em></p>
<ul>
<li>An area is a contiguous chunk of existing (allocated) virtual memory whose pages are related in some way</li>
<li> the code segment, data segment, heap, shared library segment, and user stack are all distinct areas.</li>
<li>The kernel maintains a <strong>distinct task structure</strong> (<code>task_ struct</code> in the source code) for each process in the system.<ul>
<li>The elements of the task structure either contain or point to all of the information that the kernel needs to run the process (e.g., the PID, pointer to the user stack, name of the executable object file, and program counter)</li>
</ul>
</li>
</ul>
<p><img src="/2021/10/05/CSAPP/Ch9/taskstruct.png" alt="task structure"></p>
<ul>
<li>One of the entries in the task structure points to an <code>mm_struct</code> that characterizes the current state of the virtual memory.<ul>
<li><code>pgd</code>, which points to <strong>the base of the level 1 table</strong> (the page global directory)</li>
<li><code>mmap</code>, which points to a list of <code>vm_area_structs</code> (area structs), each of which characterizes <strong>an area of the current virtual address space</strong></li>
</ul>
</li>
</ul>
<p><code>fvm_start</code> Points to the beginning of the area. </p>
<p><code>vm_end</code>. Points to the end of the area.</p>
<p><code>vm_prot</code>. Describes the read/write permissions for all of the pages contained in the area. </p>
<p><code>vm_flags</code>. Describes (among other things) whether the pages in the area are shared with other processes or private to this process. </p>
<p><code>vm_next</code>. Points to the next area struct in the list.</p>
<h4 id="Linux-Page-Fault-Exception-Handling"><a href="#Linux-Page-Fault-Exception-Handling" class="headerlink" title="Linux Page Fault Exception Handling"></a>Linux Page Fault Exception Handling</h4><p><img src="/2021/10/05/CSAPP/Ch9/pagefaulthandler.png" alt="page fault handling"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">trigger_address</span>):</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># So in practice, Linux superimposes a tree on the list, using some fields that we have not shown, and performs the search on this tree</span></span><br><span class="line">    <span class="keyword">for</span> AreaStruct <span class="keyword">in</span> AreaStructList:</span><br><span class="line">        <span class="keyword">if</span> AreaStruct.vm_start &lt;= trigger_address &lt;= AreaStruct.vm_end:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isLegal</span>(<span class="params">trigger_address</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Does the process have permission to read, write, or execute the pages in this area? For example, was the page fault the result of a store instruction trying to write to a readonly page in the code segment?&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PageFaultHandler</span>(<span class="params">trigger_address</span>):</span></span><br><span class="line">    <span class="keyword">if</span> isValid(trigger_address) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> SegmentationFault</span><br><span class="line">        <span class="comment"># terminates the process</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isLegal(trigger_address) == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">raise</span> ProtectionException</span><br><span class="line">        <span class="comment"># terminates the process</span></span><br><span class="line">     </span><br><span class="line">     <span class="string">&#x27;&#x27;&#x27;selecting a victim page, swapping out the victim page if it is dirty, swapping in the new page,and updating the page table.&#x27;&#x27;&#x27;</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   </span><br><span class="line"><span class="comment"># When the page fault handler returns, the CPU restarts the faulting instruction, which sends A to the MMU again.</span></span><br></pre></td></tr></table></figure>
<h2 id="9-8-Memory-Mapping"><a href="#9-8-Memory-Mapping" class="headerlink" title="9.8 Memory Mapping"></a>9.8 Memory Mapping</h2><p><em>Linux initializes the contents of a virtual memory area by <strong>associating it with an object on disk</strong>, a process known as <strong>memory mapping</strong></em></p>
<p>Areas can be mapped to one of two types of objects:</p>
<ul>
<li>Regular file in the Linux file system<ul>
<li>The file section is divided into page-size pieces, with each piece containing the initial contents of a virtual page. </li>
<li>Because of demand paging, none of these virtual pages is actually swapped into physical memory until the CPU first touches the page</li>
<li>If the area is larger than the file section, then the area is padded with zeros.</li>
</ul>
</li>
<li>Anonymous file<ul>
<li>An area can also be mapped to an anonymous file, created by the kernel, that <strong>contains all binary zeros</strong>.</li>
<li>The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, <strong>overwrites the victim page with binary zeros</strong>, and updates the page table to mark the page as resident.</li>
<li>Notice that <strong>no data are actually transferred between disk and memory</strong> if no dirty page</li>
</ul>
</li>
</ul>
<p>In either case, once a virtual page is initialized, it is swapped back and forth between a special <strong>swap file</strong>(aka <strong>swap space</strong> or the <strong>swap area</strong>) maintained by the kernel.</p>
<p><strong><em>At any point in time, the swap space bounds the total amount of virtual pages that can be allocated by the currently running processes.</em></strong></p>
<h3 id="9-8-1-Shared-Objects-Revisited"><a href="#9-8-1-Shared-Objects-Revisited" class="headerlink" title="9.8.1 Shared Objects Revisited"></a>9.8.1 Shared Objects Revisited</h3><p><em>If the virtual memory system could be integrated into the conventional file system, then it could provide a simple and efficient way to load programs and data into memory</em></p>
<p>An object can be mapped into an area of virtual memory as either a <strong>shared object</strong> or a <strong>private object</strong></p>
<h5 id="Shared"><a href="#Shared" class="headerlink" title="Shared"></a>Shared</h5><p><img src="/2021/10/05/CSAPP/Ch9/sharedobj.png" alt="shared object"></p>
<ul>
<li>Only a single copy of the shared object needs to be stored in physical memory, even though the object is mapped into multiple shared areas.</li>
</ul>
<h5 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h5><p><img src="/2021/10/05/CSAPP/Ch9/privateobj.png" alt="private object"></p>
<ul>
<li>Private objects are mapped into virtual memory using a clever technique known as <strong>copy-on-write</strong></li>
<li> A private object begins life in exactly the same way as a shared object, <strong>with only one copy of the private object stored in physical memory</strong></li>
<li>For each process that maps the private object, the page table entries for the corresponding private area are flagged as <strong>read-only</strong>, and the area struct is flagged as <strong>private copy-on-write</strong>.</li>
<li>As soon as a process attempts to write to some page in the private area, the write <strong>triggers a protection fault</strong>.</li>
<li>When the fault handler notices that the protection exception was caused by the process trying to write to a page in a private copy-on-write area, <strong>it creates a new copy of the page in physical memory, updates the page table entry to point to the new copy, and then restores write permissions to the page</strong></li>
<li>When the fault handler returns, the CPU re-executes the write, which now <strong>proceeds normally on the newly created page</strong>.</li>
<li>By <strong>deferring the copying of the pages in private objects until the last possible moment</strong>, copy-on-write makes the most efficient use of scarce physical memory</li>
</ul>
<h3 id="9-8-2-The-fork-Function-Revisited"><a href="#9-8-2-The-fork-Function-Revisited" class="headerlink" title="9.8.2 The fork Function Revisited"></a>9.8.2 The <code>fork</code> Function Revisited</h3><p>When the <code>fork</code> function is called by the current process :</p>
<ul>
<li>The kernel creates <strong>various data structures for the new process</strong> and assigns it a unique PID.</li>
<li>creates exact copies of the current process’s <code>mm_struct</code>, <code>area structs</code>, and <code>page tables</code>.(Now the memory copy of the old process has already been created!!!)</li>
<li>It flags each page in both processes as <strong>read-only</strong>, and flags each area struct in both processes as <strong>private copy-on-write</strong>.</li>
<li>When the <code>fork</code> returns in the new process, <strong>the new process now has an exact copy of the virtual memory as it existed</strong> when the <code>fork</code> was called</li>
<li>When either of the processes performs any subsequent writes, the copy-on-write mechanism creates new pages</li>
</ul>
<h3 id="9-8-3-The-execve-Function-Revisited"><a href="#9-8-3-The-execve-Function-Revisited" class="headerlink" title="9.8.3 The execve Function Revisited"></a>9.8.3 The <code>execve</code> Function Revisited</h3><p>When <code>execve(&quot;a.out&quot;, NULL, NULL);</code>, the following steps are performed</p>
<p><img src="/2021/10/05/CSAPP/Ch9/override.png" alt="override memory space"></p>
<ul>
<li><strong>Delete existing user areas</strong>. Delete the existing area structs in the user portion of the current process’s virtual address</li>
<li><strong>Map private areas.</strong> Create new area structs for the code, data, bss, and stack areas of the new program. All of these new areas are private copy-on-write. The code and data areas are mapped to the .text and .data sections of the a.out file. The bss area is demand-zero, mapped to an anonymous file whose size is contained in a.out. The stack and heap area are also demand-zero, initially of zero length. </li>
<li><strong>Map shared areas.</strong></li>
<li><strong>Set the program counter (PC)</strong>. The last thing that execve does is to set the program counter in the current process’s context to point to the entry point in the code area.</li>
</ul>
<h3 id="9-8-4-User-Level-Memory-Mapping-with-the-mmap-Function"><a href="#9-8-4-User-Level-Memory-Mapping-with-the-mmap-Function" class="headerlink" title="9.8.4 User-Level Memory Mapping with the mmap Function"></a>9.8.4 User-Level Memory Mapping with the <code>mmap </code>Function</h3><p><em>Linux processes can use the <code>mmap</code> function to <strong>create new areas of virtual memory and to map objects into these areas</strong>.</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//Returns: pointer to mapped area if OK, MAP_FAILED (−1) on error</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/05/CSAPP/Ch9/mmp.png" alt="memory map"></p>
<ul>
<li>The <code>mmap</code> function asks the kernel to <strong>create a new virtual memory area</strong>, preferably one that starts at address <code>start</code>, and to <strong>map a contiguous chunk of the object specified by file descriptor <code>fd</code> to the new area</strong></li>
<li>The contiguous object chunk has a size of <code>length</code> bytes and starts at an <code>offset</code> of offset bytes from the beginning of the file. </li>
<li>The start address is merely a hint(the final decision is made by kernal), and is usually specified as <code>NULL</code>.</li>
<li>The <code>prot</code> argument contains bits that describe the <strong>access permissions</strong> of the newly mapped virtual memory area</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;PROT_EXEC : <span class="string">&quot;Pages in the area consist of instructions that may be executed by the CPU.&quot;</span>,</span><br><span class="line">PROT_READ : <span class="string">&quot;Pages in the area may be read.&quot;</span>,</span><br><span class="line">PROT_WRITE : <span class="string">&quot;Pages in the area may be written&quot;</span>,</span><br><span class="line">PROT_NONE :<span class="string">&quot;Pages in the area cannot be accessed.&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The <code>flags</code> argument consists of bits that <strong>describe the type of the mapped object.</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     MAP_ANON : <span class="string">&quot;the backing store is an anonymous object and the corresponding virtual pages are demand-zero&quot;</span>,</span><br><span class="line">     MAP_PRIVATE : <span class="string">&quot;A private copy-on-write object&quot;</span>,</span><br><span class="line">     MAP_SHARED : <span class="string">&quot;A shared object&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>The <code>munmap</code> function deletes regions of virtual memory:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//Returns: 0 if OK, −1 on error</span></span><br></pre></td></tr></table></figure>
<p>The <code>munmap</code> function deletes the area starting at virtual address <code>start</code> and consisting of the next <code>length</code> bytes. Subsequent references to the deleted region result in segmentation faults.</p>
<h4 id="Practice-Problem-9-5"><a href="#Practice-Problem-9-5" class="headerlink" title="Practice Problem 9.5"></a>Practice Problem 9.5</h4><blockquote>
<p>Write a C program <code>mmapcopy.c</code> that uses <code>mmap</code> to copy an arbitrary-size disk file to<code> stdout</code>. The name of the input file should be passed as a command-line argument.</p>
</blockquote>
<h4 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution :"></a>My solution :</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//No error checking below</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> * argv [])</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">   <span class="keyword">size_t</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">   <span class="keyword">char</span> * res = mmap(<span class="literal">NULL</span> , len, PROT_READ, MAP_PRIVATE, fd , <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> , res);</span><br><span class="line">   close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Modified-solution-on-the-book"><a href="#Modified-solution-on-the-book" class="headerlink" title="Modified solution on the book:"></a>Modified solution on the book:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//No error checking below</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> * argv [])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd ; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY , <span class="number">0</span> );</span><br><span class="line">    fstat(fd, &amp;stat);</span><br><span class="line">    <span class="keyword">char</span> * bufp = mmap(<span class="literal">NULL</span>, stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, bufp, stat.st_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-9-Dynamic-Memory-Allocation"><a href="#9-9-Dynamic-Memory-Allocation" class="headerlink" title="9.9 Dynamic Memory Allocation"></a>9.9 Dynamic Memory Allocation</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://rubbish-and-world.github.io/2021/10/05/CSAPP/Ch9/" data-id="ckufhrqw500007jyqdje3h46q" data-title="Ch9" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/09/29/CSAPP/cachelab/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">cachelab</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cryptography/">Cryptography</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Data-Structure/">Data Structure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electronics/">Electronics</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/NTU/">NTU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/Stanford-CS229/">Stanford CS229</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Math/Discrete-Mathematics/">Discrete Mathematics</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Networking/">Networking</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Networking/Stanford-CS144/">Stanford CS144</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python-OG/">Python OG</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/csapp/">csapp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/csapp/Stanford-CS144/">Stanford CS144</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/game/" style="font-size: 10px;">game</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/05/CSAPP/Ch9/">Ch9</a>
          </li>
        
          <li>
            <a href="/2021/09/29/CSAPP/cachelab/">cachelab</a>
          </li>
        
          <li>
            <a href="/2021/09/28/CSAPP/Ch8PartII/">Ch8PartII</a>
          </li>
        
          <li>
            <a href="/2021/09/25/Network/IPv4address/">IPv4address</a>
          </li>
        
          <li>
            <a href="/2021/09/25/CSAPP/Ch8/">Ch8</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 rubbish<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>